<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[玩烂 Vuex]]></title>
    <url>%2F2018%2F06%2F26%2Fvuex-record%2F</url>
    <content type="text"><![CDATA[先附上 Vuex Demo 源码～ Vuex 概念篇Vuex 是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 什么是“状态管理模式”？从软件设计的角度，就是以一种统一的约定和准则，对全局共享状态数据进行管理和操作的设计理念。你必须按照这种设计理念和架构来对你项目里共享状态数据进行CRUD。所以所谓的“状态管理模式”就是一种软件设计的一种架构模式（思想）。 为什么需要这种“状态管理模式”应用到项目中呢？现如今，流行组件化、模块化开发，多人开发各自组件的时候，不难保证各个组件都是唯一性的，多个组件共享状态肯定是存在的，共享状态又是谁都可以进行操作和修改的，这样就会导致所有对共享状态的操作都是不可预料的，后期出现问题，进行 debug 也是困难重重，往往我们是尽量去避免全局变量。 但大量的业务场景下，不同的模块（组件）之间确实需要共享数据，也需要对其进行修改操作。也就引发软件设计中的矛盾：模块（组件）之间需要共享数据 和 数据可能被任意修改导致不可预料的结果。 为了解决其矛盾，软件设计上就提出了一种设计和架构思想，将全局状态进行统一的管理，并且需要获取、修改等操作必须按我设计的套路来。就好比马路上必须遵守的交通规则，右行斑马线就是只能右转一个道理，统一了对全局状态管理的唯一入口，使代码结构清晰、更利于维护。 Vuex 是借鉴了 Flux 、Redux 和 The Elm Architecture 架构模式、设计思想的产物。 什么情况下我应该使用 Vuex？不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。应用够简单，最好不要使用 Vuex。一个简单的 global event bus (父子组件通信，父组件管理所需的数据状态)就足够您所需了。构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。 个人见解，什么时候用？管你小中大型应用，我就想用就用呗，一个长期构建的小型应用项目，谁能知道项目需求以后会是什么样子，毕竟在这浮躁的时代，需求就跟川剧变脸一样快，对不对？毕竟学习了 Vuex 不立马用到项目实战中，你永远不可能揭开 Vuex 的面纱。项目中使用多了，自然而然就会知道什么时候该用上状态管理，什么时候不需要。老话说的好熟能生巧，你认为呢？（括弧 – 先了解好Vuex 一些基本概念，然后在自己的项目中使用过后，再用到你公司项目上，你别这么虎一上来就给用上去了～） Vuex 基本使用篇安装1npm i vuex -S 项目全局中任何地方使用 Vuex, 需要将 Vuex 注册到 Vue 实例中： 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) Vuex 上车前的一个🌰上车规则： 每一个 Vuex 应用的核心就是 store（仓库），一个项目中必须只有一个 store 实例。包含着你的应用中大部分的状态 (state)。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。 Vuex 和单纯的全局对象有以下两点不同：（1） Vuex 的状态存储是响应式的。Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。（2）不能直接改变 store 中的状态。（重要的事情多来一遍） 上🌰： 1234567&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click="increment"&gt;+&lt;/button&gt; &lt;button @click="decrement"&gt;-&lt;/button&gt; &lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) // Vuex 注册到 Vue 中// 创建一个 storeconst store = new Vuex.Store(&#123; // 初始化 state state: &#123; count: 0 &#125;, // 改变状态唯一声明处 mutations: &#123; increment: state =&gt; state.count++, decrement: state =&gt; state.count-- &#125;&#125;)new Vue(&#123; el: '#app', // 从根组件将 store 的实例注入到所有的子组件 store, computed: &#123; count () &#123; // Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态, // 每当状态 count 发生变化，都会重新求取计算 return this.$store.state.count &#125; &#125;, methods: &#123; increment () &#123; this.$store.commit('increment') &#125;, decrement () &#123; this.$store.commit('decrement') &#125; &#125;&#125;) state 一个对象管理应用的所有状态，唯一数据源（SSOT, Single source of truth），必须前期初始化就定义好，不然后面在来修改设置 state，程序就不会捕获到 mutations(突变的意思) 所以数据也就不会又任何的更新，组件上也无法体现出来。 获取 store 管理的状态， 因为在 Vue 实例化的时候将 Vuex store 对象 注入了进来 ，所以任何地方都可以通过 this.$store 获取到 store, this.$store.state 来获取状态对象， this.$store.commit 来触发之前定义好的 mutations 中的方法 123this.$store.state('count') // =&gt; 0this.$store.commit('increment') // =&gt; 1 通过提交 mutation 的方式，而非直接改变 store.state.count, 使用 commit 方式可以让 Vuex 明确地追踪到状态的变化，利于后期维护和调试。 通过了解 state （状态，数据）和 mutations （修改数据唯一声明的地方，类似 SQL 语句）知道了 Vuex 最重要的核心两部分，然后通过掌握 gttter、action、module 来让 Vuex 更加的工程化、合理化来适应更大型的项目的状态管理。 mapState 辅助函数mapState 可以干什么呢？字面意思状态映射，通过 mapState 可以更加快捷方便帮我们生成计算属性，拿上面的例子进行演示： 12345678910111213141516171819202122 computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;// 使用 mapStateimport &#123; mapState &#125; from 'vuex' // 需要先导入computed: mapState([ // 箭头函数方式 count: state =&gt; state.count , // or 传字符串参数方式, 'count' 等同于 state =&gt; state.count countAlias: 'count' // 获取状态后，你还需要和当前组件别的属性值时,就必须使用常规函数的写法了, 只有这样才能获取到当前组件的 this countPlusLocalState (state) &#123; return state.count + this.localCount &#125;]) 当前计算属性名称和状态名称相同时，可以传递一个字符串数组： 1234computed: mapState([ // 映射 `this.count` 为 `this.$store.state.count` 'count']) 以上使用 mapState 辅助函数后，整个 computed 计算属性都成了 state 状态管理聚集地了， 组件里并不是所有的计算属性都需要被状态管理化，还是有很多计算属性是不需要状态管理的数据的，那如何将它与局部计算属性混合使用呢？ 因为 mapState 函数返回的是一个对象。所以我们使用对象扩展运算符就可以把局部计算属性和 mapState 函数返回的对象融合了。 123456789computed: &#123; ...mapState(&#123; count: state =&gt; state.count &#125;), localComputed () &#123; /* ... */ &#125;&#125; ⚠️ 注意： 对象扩展运算符，现处于 ECMASCript 提案 stage-4 阶段（将被添加到下一年度发布），所以项目中要使用需要安装 babel-plugin-transform-object-rest-spread 插件 或 安装 presets 环境为 stage 为 1的 env 版本 babel-preset-stage-1 和修改 babelrc 配置文件 .babelrc 12345678910&#123; "presets": [ "env", "stage-1" // 添加此项 ], "plugins": [ "transform-vue-jsx", "syntax-dynamic-import" ]&#125; 核心概念 上面以讲述过 state 了，这里就不过多的说明。 GetterGetter 就是 Store 状态管理层中的计算属性，获取源 State 后，希望在对其进行一些包装，再返回给组件中使用。也是就将直接获取到 State 后在 computed 里进行再次的过滤、包装逻辑统统提取出放到 Getter 里进行，提高了代码的复用性、可读性。 12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 提取到 Getter： 123456789101112131415161718192021222324const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, // `Getter` 默认第一个参数为 `state`: getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter( todo =&gt; todo.done ) &#125; &#125;&#125;)// 组件中获取，通过属性访问computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodos.length &#125;&#125; ⚠️ 注意： getter 在通过属性访问时是作为 Vue 的响应式系统的一部分进行缓存。 Getter 还接受其他 getter 作为第二个参数 123456789101112131415161718const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter( todo =&gt; todo.done ) &#125;, // 第二个参数为 getters doneTodosLength: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125; &#125;&#125;) 还可以通过给 Getter 传递参数获取特定的数据 12345678getters: &#123; // ... getTodoById: state =&gt; id =&gt; &#123; return state.todos.find( todo =&gt; todo.id === id ) &#125;&#125; 组件内调用方式12this.$store.getters.getTodoById(2) // =&gt; &#123; id: 2, text: '...', done: false &#125; ⚠️ 注意：getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。 mapGetters 辅助函数和前面 mapState 辅助函数作用和使用上基本相同。 12345678910111213141516171819202122232425import &#123; mapGetters &#125; from 'vuex'// getter 名称和 计算属性名称相同的情况下，可以传递字符串数组export default &#123; // ... computed: &#123; ...mapGetters([ 'doneTodos' ]) &#125;&#125;// 传递对象的方式export default &#123; // ... computed: &#123; ...mapGetters(&#123; doneTodos: 'doneTodos', getTodoById: 'getTodoById' // 此处传递回来的是一个函数，所以在使用的时候 =&gt; &#123;&#123; getTodoById(2) &#125;&#125; &#125;) &#125;&#125; Mutation不能直接修改状态，需要通过 Vuex store 中声明的 Mutations 里的方法修改状态。 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。mutation 是一个对象， 含有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。回调函数就是我们实际进行状态更改的地方，默认接受 state 作为第一个参数。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; // increment 事件类型（type）名称，increment() 回调函数 // increment: function (state) &#123;&#125; 原本写法 increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) mutation handler 不能被直接调用，需要通过 store.commit() 来通知我需要触发一个 mutation handler。 1this.$store.commit('increment') mutation 接收参数必须只能两个，超出的都无法获取；第二个参数推荐传递的是一个对象，来接收更多的信息。 12345this.$store.commit('increment', 10)// orthis.$store.commit('increment', &#123; num: 10 &#125;) 对象风格的提交方式 1234this.$store.commit(&#123; type: 'increment', num: 10&#125;) Mutation 需要遵守 Vue 的响应规则 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性（state 中的属性）。 当需要在对象上添加新属性时，你应该返回的是一个新对象* 使用 Vue.set(obj, &apos;newProp&apos;, 123)，或者 * 以新对象替换老对象。例如： `Object.assgin({}, state.obj, newProps)` 、对象扩展运算符 `state.obj = {...state.obj, newProp: 123 }` mapMutation 辅助函数使用方式跟 mapState 和 mapGetters 基本相同。 12345678910111213141516171819import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; // 传递字符串数组，同名哦～ ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), // 传递对象 ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; 调用方式就跟 methods 其他普通方法一样，通过 this.&lt;methodName&gt; 来调用。 ⚠️ 注意：mutation 必须是同步函数，修改 state 必须是同步的、同步的、同步的。如果是异步的，当触发 mutation 的时候，内部的回调函数还没有被调用，根本不知道实际执行在何处，很难追踪起问题。（实质上任何在回调函数中进行的状态的改变都是不可追踪的。Vuex 也提供了异步操作的解决方案， 需要将异步操作提取出来放入到 Action 里进行操作。而 Mutation 只负责同步事务。 Action在之前也讲述了，Action 是用来处理异步操作的。这里在详细说明一下 Action 的基本使用。 Action 类似于 mutation， 不同在于: Action 提交的是 mutation，而不是直接变更状态。(不直接修改状态，修改状态还是需要通过 mutation) Action 可以包含任意异步操作。 12345678910111213141516const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; // 实践中，经常用到参数解构来简化代码， increment (&#123;commit&#125;) &#123; commit('') &#125; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象（并不是真正的 store 本身），因此可以调用 store.commit 进行提交 mutation， 或者通过 context.state 和 context.getters 来获取 state 和 getters。 触发Action Action 通过 store.dispatch 方法触发： 123456789101112this.$store.dispatch('increment')// 以传递额外参数分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 与服务器数据异步请求基本在 Action 里进行， 然后通过 Mutation 来同步应用状态state mapAction 辅助函数和 mapMutions 使用方式基本一致。 123456789101112131415161718import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), // 传递对象 ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 组合 ActionAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 通过返回一个 Promise 对象来进行组合多个 Action。 1234567891011actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125; 然后： 123store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) 利用 async / await，我们可以如下组合 action： 123456789101112// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; Module由于 Vuex 使用单一状态树模式，来统一管理应用所有的状态，导致所有状态会集中到一个比较大的对象，随着后续不断得迭代，这个对象就会越来越庞大，后期的代码可读性、可维护性就会不断加大。 解决以上问题，就需要对这个对象的内部进行拆分和细分化，对状态进行分门别类，也就产生了模块（module） 这个概念。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割，将庞大的系统进行合理有效的职能划分，遵循单一职责的理念，每个模块清晰明了的自己的职责和职能。 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 声明模块后，state、mutation、action、getter 等使用方式、作用和不在 modules 内声明方式基本一样，只是在细节上进行了一些细微的改变，比如： getter 里默认接收一个参数 state，模块里接收 state 就是本身模块自己的 state 状态了，而不是全局的了； 调用获取上也多一道需要告知那个模块获取状态 等一些细节上的差异。 Module 里 state、mutation、action、getter 上的一些差异（1）模块内部的 mutation 和 getter，接收的第一个参数 state 是模块的局部状态对象。（2）模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState（3）模块内部的 getter，根节点状态会作为第三个参数暴露出来 命名空间默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应，所以必须防止模块里属性或方法重名。 为了模块具有更高的封装度、复用性和独立性，可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。在调用上也就需要添加上声明 getter、action 及 mutation 到底属于那个模块了，以路径的形式表示属于那个模块。 1234567891011121314151617181920212223242526272829303132333435363738394041const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 开启命名空间 // 模块内容（module assets） state: &#123; ... &#125;, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters['account/isAdmin'] 调用时以路径的形式表明归属 &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch('account/login') &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit('account/login') &#125;, // 嵌套模块 modules: &#123; // 继承父模块的命名空间 myPage: &#123; state: &#123; ... &#125;, getters: &#123; profile () &#123; ... &#125; // -&gt; getters['account/profile'] &#125; &#125;, // 进一步嵌套命名空间 posts: &#123; namespaced: true, state: &#123; ... &#125;, getters: &#123; popular () &#123; ... &#125; // -&gt; getters['account/posts/popular'] &#125; &#125; &#125; &#125; &#125;&#125;) 在带命名空间的模块内访问全局内容带命名空间的模块内访问全局 state 、getter 和 action， rootState和 rootGetter会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 1234567891011121314151617181920212223242526272829303132modules: &#123; foo: &#123; namespaced: true, getters: &#123; // 在这个模块的 getter 中，`getters` 被局部化了 // 全局的 state 和 getters 可以作为第三、四个参数进行传入，从而访问全局 state 和 getters someGetter (state, getters, rootState, rootGetters) &#123; getters.someOtherGetter // -&gt; 'foo/someOtherGetter' rootGetters.someOtherGetter // -&gt; 'someOtherGetter' &#125;, someOtherGetter: state =&gt; &#123; ... &#125; &#125;, actions: &#123; // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; getters.someGetter // -&gt; 'foo/someGetter' rootGetters.someGetter // -&gt; 'someGetter' dispatch('someOtherAction') // -&gt; 'foo/someOtherAction' dispatch('someOtherAction', null, &#123; root: true &#125;) // -&gt; 'someOtherAction' commit('someMutation') // -&gt; 'foo/someMutation' commit('someMutation', null, &#123; root: true &#125;) // -&gt; 'someMutation' &#125;, someOtherAction (ctx, payload) &#123; ... &#125; &#125; &#125;&#125; 在带命名空间的模块注册全局 action需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。例如： 12345678910111213141516171819&#123; actions: &#123; someOtherAction (&#123;dispatch&#125;) &#123; dispatch('someAction') &#125; &#125;, modules: &#123; foo: &#123; namespaced: true, actions: &#123; someAction: &#123; root: true, handler (namespacedContext, payload) &#123; ... &#125; // -&gt; 'someAction' &#125; &#125; &#125; &#125;&#125; 带命名空间的模块里辅助函数如何使用？将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。 123456789101112computed: &#123; ...mapState('some/nested/module', &#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;)&#125;,methods: &#123; ...mapActions('some/nested/module', [ 'foo', 'bar' ])&#125; 还可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数： 1234567891011121314151617181920import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('some/nested/module')export default &#123; computed: &#123; // 在 `some/nested/module` 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) &#125;&#125; 模块动态注册在 store 创建之后，你可以使用 store.registerModule 方法注册模块： 12345678// 注册模块 `myModule`store.registerModule('myModule', &#123; // ...&#125;)// 注册嵌套模块 `nested/myModule`store.registerModule(['nested', 'myModule'], &#123; // ...&#125;) 模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。 你也可以使用 store.unregisterModule(moduleName)来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。 待更新～]]></content>
      <categories>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echo]]></title>
    <url>%2F2018%2F05%2F21%2Fecho-520%2F</url>
    <content type="text"><![CDATA[Echo这是一个网络应用程序，与我的女朋友一起庆祝 5 月 20 日（意思是“我爱你”）。 ;P 它受 iMessage 中名为 echo 的消息效果的启发。 只是让你开心。 嗯，这就是此作者的原话，满满的撒狗粮 🐶🐶🐶，但是此程序还是很有趣的对不对～所以还是拉下代码，悄悄的 👀 一波（毕竟单身汪，周末也没什么事） 预览 demo 将学到的知识点 单一 div 气泡绘制 随机大小位置 动画效果 内存回收 气泡绘制可以看出它是由一个椭圆和一个小尾巴构成。 如何绘制下这个小尾巴？ 先看下这篇文章了解下使用CSS3绘制图形基本原理 12345width: 10rem;height: 10rem;background-color: orangered;border-left: 1rem solid orange;border-bottom-left-radius: 10rem 7rem; 看此上，将背景色取掉；是不是一个小尾巴就出来了，缩小下尺寸，汽泡的小尾巴就就出来了～这里我们通过伪类元素来绘制气泡的小尾巴。 随机大小位置气泡是绝对定位的，控制随机出现的位置，其实就是控制 left和 top值。 先获取当前可视窗口尺寸 控制气泡出现的在可视窗口的范围内， left 和 top 小于可视窗口宽高的值 大小，使用 CSS3 里的 transform 属性的 scale() 来控制（肯定不能比本身的小） 123const left = Math.ceil(Math.random() * 0.9 * screenSize.width)const top = Math.ceil(Math.random() * 0.9 * screenSize.width)const scale = 1 + Math.random(); // 缩放值 内存回收内存回收实现原理，good 作为是否回收的标志（全 false 进行回收）。整个流程就是每一个消息 good 默认为 true, 当某条消息完成了消失动画以后，就会将 good 状态变为 false; 然后将固定的第一条消息以外的全部消息中的 good 提取出来。我们的最终目的是判断当前提取出来的新数组里是否还存在处于展示状态的消息，无论消息量有多少，只需要判断是否至少有一个 good 状态为 true即可，直到全部消息的 good 状态都为 false了，我们再进行内存回收 ♻️，也就是对 msgs 重置。 内存回收的实现: 123456const hasMsgs = this.msgs .slice(1) .map((&#123; good &#125;) =&gt; good) .reduce((left, right) =&gt; left || right); // 找出任意一个为 true 的状态if (!hasMsgs) this.msgs.splice(1); 参考DEMO LicenseMIT Licensed.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS 学习记录]]></title>
    <url>%2F2018%2F05%2F19%2Fangularjs-learning-record%2F</url>
    <content type="text"><![CDATA[AngularJS 初识篇Angular CLI 安装12345678910111213141516# 全局安装$ npm install -g @angular/cli# 检验安装是否成功,出现以下图标就说明成功了$ ng -v _ _ ____ _ ___ / \ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \ | &apos;_ \ / _` | | | | |/ _` | &apos;__| | | | | | | / ___ \| | | | (_| | |_| | | (_| | | | |___| |___ | |/_/ \_\_| |_|\__, |\__,_|_|\__,_|_| \____|_____|___| |___/Angular CLI: 1.7.4Node: 8.11.1OS: darwin x64Angular: 初始化新项目1234567# 创建项目成功后，会自动 npm install$ ng new helloAngular(project name)# 启动项目（开启本地服务）$ ng serve// or 启动项目，并打开浏览器 （--open or -o）$ ng serve --open ng serve指令参数含义ng serve 命令会启动开发服务器，监听文件变化，并在修改这些文件时重新构建此应用。 --open or -o 自动打开浏览器并访问 --prod 指定为生产模式，会自动打包项目 创建我的第一个组件Angular CLI 命令行工具，自带指令集，可以让我们快速开发和遵循 Angular 的开发风格指南。 1234# 创建组件 组件名需要遵循大驼峰命名规则$ ng generate component ComponentName// or 简写$ ng g c ComponentName Angular三大核心概念Angular最核心的概念是“组件化”,新版本的 Angular 来说，一切都是围绕着“组件化”展开的，组件是 Angular 的核心概念模型。 Component Module Route 以下是一个最简单的 Angular 组件定义： 12345678910import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss']&#125;)export class AppComponent &#123; title = 'Jun ting';&#125; @Component：这是一个 Decorator（装饰器），其作用类似于 Java 里面的注解。Decorator 这个语言特性目前（2017-10）处于 Stage 2（草稿）状态，还不是 ECMA 的正式规范。 selector：组件的标签名，外部使用者可以这样来使用这个组件：。默认情况下，ng 命令生成出来的组件都会带上一个 app 前缀，如果你不喜欢，可以在 angular-cli.json 里面修改 prefix 配置项，设置为空字符串将会不带任何前缀。 templateUrl：引用外部的 HTML 模板。如果你想直接编写内联模板，可以使用 template，支持 ES6 引入的“模板字符串”写法。 styleUrls：引用外部 CSS 样式文件，这是一个数组，也就意味着可以引用多份 CSS 文件。 export class AppComponent：这是 ES6 里面引入的模块和 class 定义方式。 把 CSS 预编译器改成 SASS@angular/cli 创建项目的时候没有自动使用 SASS 作为预编译器，我们需要自己手动修改一些配置文件,请按照以下步骤依次修改： 1、 angular-cli.json 里面的 styles.css 后缀改成 .scss 12345678910111213141516171819"apps": [ &#123; "root": "src", "outDir": "dist", "assets": [ "assets", "favicon.ico" ], "index": "index.html", "main": "main.ts", "polyfills": "polyfills.ts", "test": "test.ts", "tsconfig": "tsconfig.app.json", "testTsconfig": "tsconfig.spec.json", "prefix": "app", // 这里 "styles": [ "styles.scss" ], 后面再使用 ng g c *** 自动创建组件的时候，默认就会生成 .scss 后缀的样式文件了。 2、 angular-cli.json 里面的 styleExt 改成 .scss 1234"defaults": &#123; "styleExt": "scss", "component": &#123;&#125;&#125; 3、 src 下面.css后缀的文件全修改为.scss 引入 bootstrap、font-awesome安装 bootstrap、font-awesome 依赖 12345# bootstrapnpm install bootstrap --save# font-awesomenpm install font-awesome --save 在 style.scss 引入 bootstrap、font-awesome 的 css 12@import "~bootstrap/dist/css/bootstrap.min.css";@import "~font-awesome/css/font-awesome.min.css"; AngularJS 模板语法 模板是编写 Angular 组件最重要的一环，你至少需要深入理解以下知识点才能玩转 Angular 模板： 对比各种 JS 模板引擎的设计思路 Mustache（八字胡）语法， {} 模板内的局部变量 属性绑定、事件绑定、双向绑定 在模板里面使用结构型指令 ngIf、ngFor、ngSwitch 在模板里面使用属性型指令 NgClass、NgStyle、NgModel 在模板里面使用管道格式化数据 对比各种 JS 模板引擎的设计思路什么是模板引擎？ 是指利用某种模板语言将页面制成模板，再依据业务逻辑将该模板语言翻译成业务数据，从而生成最终展示页面。 简单的讲就是根据静态HTMl元素和业务逻辑处理的数据结合渲染生成浏览器器需要的页面。 jQuery -&gt; Handlebars React -&gt; jsx 模板写法 Angular -&gt; 与“指令”紧密结合的模板语法 （vue 也是一样） 各种模板引擎的唯一目标就是提高开发效率、缩短时间成本。综合来说，无论是哪一种前端模板，大家都比较推崇“轻逻辑”（ logic-less ）的设计思路。 何为“轻逻辑”? 简而言之，所谓“轻逻辑”就是说，你不能在模板里面编写非常复杂的 JavaScript 表达式。比如，Angular 的模板语法就有规定： 你不能在模板里面 new 对象 不能使用=、+=、-=这类的表达式 不能用++、–运算符 不能使用位运算符 为什么要“轻逻辑”？ 本身的 Html 是不识别 if 、for 等操作的；模板引擎处于的地位就是帮忙编译转换纯HTMl元素。 在 HTML 加入复杂的逻辑，会加大模板引擎编译的时间和计算能力；而且也不建议复杂逻辑处理放到HTMl里来做，保证 HTML 的单一纯洁性；使用模板也是来做简单的插值相关的操作 JS 版的编译器需要在浏览器里面运行，搞得太复杂浏览器拖不动！ 最根本还是模板引擎不够强, 并不是万能的； 对于 Angular 来说，强调“轻逻辑”还有另一个原因：在组件的整个生命周期里面，模板函数会被执行很多次。你可以想象， Angular 每次要刷新组件的外观的时候，都需要去调用一下模板函数，如果你在模板里面编写了非常复杂的代码，一定会增加渲染时间，用户一定会感到界面有“卡顿”。 人眼的视觉延迟大约是100ms到400ms之间，如果整个页面的渲染时间超过400ms，界面基本上就卡得没法用了。有一些做游戏的开发者会追求60fps刷新率的细腻感觉，60分之1秒约等于16.7ms，如果 UI 整体的渲染时间超过了16.7ms，就没法达到这个要求了。 轻逻辑（ logic-less ）带来了效率的提升，也带来了一些不方便，比如很多模板引擎都实现了 if 语句，但是没有实现 else，所以开发者们在编写复杂业务逻辑的时候模板代码会显得非常啰嗦。 目前来说，并没有完美的方案能同时兼顾运行效率和语法表现能力，这里只能取一个平衡。 Mustache 语法关于 Mustache 语法，双花括号语法,你需要掌握3点: 它可以获取到组件里面定义的属性值。 它可以自动计算简单的数学表达式，例如: 加减乘除、取模 它可以获得方法的返回值。 插值语法关键代码实例： 123&lt;h3&gt; 欢迎来到&#123;&#123;title&#125;&#125;！&lt;/h3&gt; 1public title = 'Mustache 语法'; 简单的数学表达式求值： 1&lt;p&gt;1 + 5 = &#123;&#123; 1 + 5 &#125;&#125;&lt;/p&gt; 调用组件里面定义的方法： 1&lt;p&gt; &#123;&#123; getStr() &#125;&#125; &lt;/p&gt; 123public getStr(): string &#123; return '调用方法！'&#125; 属性绑定（[属性名]）属性绑定是用方括号来做的，写法： 12&lt;img [src]="imgSrc" /&gt;&lt;button [disabled]="isUnchanged"&gt;是否禁用&lt;/button&gt; 12public imgSrc:string = './images.png';public isUnchanged:boolean = true; 很明显，这种绑定是单向数据绑定，单一的读取值而已。 事件绑定 ( (事件名) )事件绑定是用圆括号来做的，写法： 1&lt;button (click)="btnClick($event)"&gt;点击事件&lt;/button&gt; 123pubic btnClick(e):void &#123; alert('点击事件测试～');&#125; 双向绑定 （ [(…)] ）你经常需要显示数据属性，并在用户作出更改时更新该属性。 在元素层面上，既要设置元素属性，又要监听元素事件变化。 双向绑定是通过方括号里面套一个圆括号 [(...)] 来做的，模板写法： 1&lt;app-sizer [(size)]="fontSizePx"&gt;&lt;/app-sizer&gt; 1public fontSizePx:number = 14; 模板内的局部变量在模板里面使用结构型指令Angular 有3个内置的结构型指令：*ngIf、*ngFor、ngSwitch。ngSwitch 的语法比较啰嗦，使用频率小一些, 了解就好。 *ngIf 代码实例： 12&lt;p *ngIf="isShow"&gt;显示还是不显示？&lt;/p&gt;&lt;button (click)="toggleShow()"&gt;控制显示隐藏&lt;/button&gt; 12345public isShow:boolean=true;public toggleShow():void &#123; this.isShow = !this.isShow;&#125; *ngFor 代码实例： 12345&lt;ul&gt; &lt;li *ngFor="let item of items; let i = index;"&gt; &#123;&#123;i+1&#125;&#125; - &#123;&#123; item.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345public items:Array&lt;any&gt;=[ &#123;name:"PyCoder"&#125;, &#123;name:"Jun ting"&#125;, &#123;name:"EcmaScript"&#125;]; *ngSwitch 代码实例： 12345&lt;div [ngSwitch]="mapStatus"&gt; &lt;p *ngSwitchCase="0"&gt;下载中...&lt;/p&gt; &lt;p *ngSwitchCase="1"&gt;正在读取...&lt;/p&gt; &lt;p *ngSwitchDefault&gt;系统繁忙...&lt;/p&gt;&lt;/div&gt; 1public mapStatus:number = 1; 特别注意：一个 HTML 标签上只能同时使用一个结构型的指令。 因为“结构型”指令会修改 DOM 结构，如果在一个标签上使用多个结构型指令，大家都一起去修改 DOM 结构，到时候到底谁说了算？ 那么需要在同一个 HTML 上使用多个结构型指令应该怎么办呢？有两个办法： 加一层空的 div 标签进行包裹 加一层 &lt;ng-container&gt; 在模板里面使用属性型指令使用频率比较高的3个内置指令是：NgClass、NgStyle、NgModel。 NgClass 使用案例代码： 12&lt;div [ngClass]="currentClasses"&gt;同时批量设置多个样式&lt;/div&gt;&lt;button (click)="setCurrentClasses()"&gt;设置&lt;/button&gt; 12345678910111213public currentClasses: [];public canSave: boolean = true;public isUnchanged: boolean = true;public isSpecial: boolean = true;public setCurrentClasses ():void &#123; this.currentClasses = &#123; 'saveable': this.canSave, 'modified': this.isUnchanged, 'special': this.isSpecial &#125;&#125;]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac - 打造自己的工作流]]></title>
    <url>%2F2018%2F05%2F19%2Fmac-make-self-workflow%2F</url>
    <content type="text"><![CDATA[Homebrew - Mac 必备软件管理神器基本市面上的软件都能通过 brew install softwareName 的方式进行安装。例如： git、google-chrmoe… 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; ITerm2 + oh-my-zsh - 终端命令行工具当然还是通过 brew进行安装 ITerm212# ITerm2$ brew install caskroom/cask/iterm2 都安装好后，我们就来配置下终端命令行工具，让它变的超酷起来。 1. iTerm2 -&gt; Make iTerm2 Default Term 2. 打开偏好设置preference，选中Keys，勾选Hotkey下的Show/hide iTerm2 with a system-wide hotkey，将热键设置为 ⌘+. ，这样你就可以通过 ⌘+. 全局热键来打开或关闭iTerm2窗口，非常方便 3. 配色方案，选用 solarized，下载解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors 4. 安装 oh-my-zsh 12# oh-my-zsh$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 5. 配置主题 1、 用 vim 编辑隐藏文件 .zshrc， 终端输入vi ~/.zshrcZSH_THEME=”agnoster” 将zsh主题修改为“agnoster” 2、 应用“agnoster”主题需要特殊的字体支持，否则会出现乱码情况， 使用 Meslo 字体，点开链接点击 view raw 下载字体 3、 安装字体到系统字体册 4、 在iTerm2中应用字体 iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font） 5、 重新打开iTerm2窗口（或新打开一个iTerm2窗口）即可以看到字体效果 推荐powerlevel9k 主题 1$ git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 然后编辑你的~/.zshrc，设置主题ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot; 6. 自动提示与命令补全 1、克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下 1$ git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 2、用 vim 编辑 .zshrc 文件，找到插件设置命令，默认是 plugins=(git) ，我们把它修改为plugins=(zsh-autosuggestions git) PS：当你重新打开终端时可能看不到变化，可能你的字体颜色太淡了，我们把其改亮一些： cd ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 用 vim 编辑 zsh-autosuggestions.zsh 文件，修改ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=10&#39; 7. 语法高亮效果 1$ brew install zsh-syntax-highlighting 在.zshrc文件的末尾添加下面这一段： 1source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 然后，加载.zshrc配置 1$ source ~/.zshrc 这里我使用的是 powerlevel9k 主题, 所以我的首行提示是这样修改的, 在 .zshrc文件末尾增加下面一行： 12# Powerlevel9k Theme configPOWERLEVEL9K_CONTEXT_TEMPLATE="%n" 或者，所有主题都适用的方式,还是在.zshrc文件里进行配置： 123456789 ZSH_THEME="powerlevel9k/powerlevel9k"# 隐藏用户名称(user@hostname) DEFAULT_USER=`id -un`# 含有icon的字型,前提你的字体有iconPOWERLEVEL9K_MODE='nerdfont-complete'# command line 左边提示内容(文件夹路径、文件夹读写状态、版本控制资讯)POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs) # &lt;= left prompt 设了 "dir"# command line 右边提示内容(状态、时间)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status time) 详细配置 最后显示成果： Visual Studio Code 终端配置字体： for Source Code Pro: “terminal.integrated.fontFamily”: “Source Code Pro for Powerline” for Meslo: “terminal.integrated.fontFamily”: “Meslo LG M for Powerline” the fontsize e.g.: “terminal.integrated.fontSize”: 14 推荐教材1*英文推荐教材2*中文 NVM - Node Version Manager 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 如果重启终端后发现，nvm 未找到此命令， 将下面的源代码行添加到您的配置文件（〜/ .bash_profile，〜/ .zshrc，〜/ .profile或〜/ .bashrc） 123export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion 安装Node 12345678# install$ nvm install 8# use$ nvm use default$ node -v$ npm -v NRM – NPM registry manager123456789# 全局安装$ npm install -g nrm# 查看当前 npm 源列表$ nom ls# 选择 taobao 源$ nom use taobao# 查看 npm 源是否更改$ npm config get]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3绘制腾讯QQ企鹅]]></title>
    <url>%2F2018%2F05%2F19%2Fcss3-qq-logo%2F</url>
    <content type="text"><![CDATA[绘制我们的企鹅 前提，你已经看过CSS3 绘制图形基本原理一文，已对一些基本图形绘制了解。 在线浏览 开始着手于 QQ 企鹅的绘制, 第一步基本框架的绘制。 通过对 Logo 图像的观察，按照层次划分来组合最终的效果。选择使用绝对位置 position:absolute;来布局各个元素。主要划分为头部，身体，围脖，双手，双脚。 1234567891011&lt;!-- QQ Logo box --&gt;&lt;div id="qq"&gt; &lt;!-- 头 --&gt; &lt;div class="head"&gt;&lt;/div&gt; &lt;!-- 身体 --&gt; &lt;div class="body"&gt;&lt;/div&gt; &lt;!-- 手 --&gt; &lt;div class="handWrapper"&gt;&lt;/div&gt; &lt;!-- 脚 --&gt; &lt;div class="footWrapper"&gt;&lt;/div&gt;&lt;/div&gt; 基本框架结构就是这样的，QQ 对于容器是通过绝对定位来对每个元素布局进行设置的。 QQ Logo 容器（画板）： 12345678910/** * QQ Logo 绘制 */#qq &#123; position: relative; margin: 0 auto; width: 420px; height: 400px; outline: gold solid 2px;&#125; 骨架出来了，那我们就开始一步步的进行绘制了，先从头开始： 绘制 head 前，还是跟步骤 1 一样，先对 head 的层次结构划分清楚，依次为：左眼、右眼、上嘴唇、下嘴唇、嘴唇的层次感体现 12345678910111213 &lt;!-- 头 --&gt;&lt;div class="head"&gt; &lt;!-- 左眼 --&gt; &lt;div class="left eye"&gt;&lt;/div&gt; &lt;!-- 右眼 --&gt; &lt;div class="right eye"&gt;&lt;/div&gt; &lt;!-- 上嘴唇 --&gt; &lt;div class="mouthTopContainer"&gt;&lt;/div&gt; &lt;!-- 下嘴唇 --&gt; &lt;div class="mouthBottomContainer"&gt;&lt;/div&gt; &lt;!-- 嘴唇上下层次感 --&gt; &lt;div class="lispContainer"&gt;&lt;/div&gt; &lt;/div&gt; 绘制 head 的轮廓： 1234567891011121314/* QQ head */.head &#123; position: absolute; top: 18px; left: 96px; width: 234px; height: 185px; border: 1px solid #000; /* 通过对border-radius 圆弧的层度来进行钩画 */ border-top-left-radius: 117px 117px; border-top-right-radius: 117px 117px; border-bottom-left-radius: 117px 68px; border-bottom-right-radius: 117px 68px;&#125; 图中为什么圆弧是设置成 border-bottom-left-radius: 117px 68px; 一般根据设计图出来后导出转成带有标尺图后，会自动计算出值；如果没有的话，那就要通过计算了。 然后依次绘制 head 其他结构： 眼睛 123456789101112131415161718/* 眼睛 */.eye &#123; position: absolute; width: 44px; height: 66px; border: 1px solid #000; border-radius: 50% 50%;&#125;.left.eye &#123; left: 62px; top: 50px;&#125;.right.eye &#123; left: 132px; top: 50px;&#125; 嘴 123456789101112131415161718/* QQ head -&gt; mouth */.mouthTopContainer &#123; position: absolute; top: 120px; left: 39px; width: 158px; height: 29px; border: 1px solid #000;&#125;.mouthBottomContainer &#123; position: absolute; top: 146px; left: 39px; width: 158px; height: 15px; border: 1px solid #000;&#125; 到这里基本头的骨架就出来，然后就是对头的骨架结构的线条进行修饰，现在太丑了，对吧！ 眼睛 12345678910111213&lt;!-- 左眼 --&gt;&lt;div class="left eye"&gt; &lt;!-- 眼球 --&gt; &lt;div class="innerLeftEye"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 右眼 --&gt; &lt;div class="right eye"&gt; &lt;!-- 眼球 --&gt; &lt;div class="innerRightEye"&gt; &lt;!-- 月牙眼球两端圆弧修饰 --&gt; &lt;div class="fix"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* QQ head -&gt; eye */.eye &#123; position: absolute; width: 44px; height: 66px; border: 1px solid #000; border-radius: 50% 50%;&#125;.left.eye &#123; left: 62px; top: 50px;&#125;.right.eye &#123; left: 132px; top: 50px;&#125;.innerLeftEye &#123; position: absolute; top: 20px; left: 20px; width: 18px; height: 24px; border-radius: 50%; border: 1px solid #000;&#125;.innerLeftEye::after &#123; content: ""; position: absolute; top: 6px; left: 9px; width: 6px; height: 8px; border: 1px solid #000; border-radius: 50%;&#125;.innerRightEye &#123; position: absolute; top: 20px; left: 8px; /* 月牙眼球外轮廓 */ width: 18px; height: 24px; border: 1px solid #000; border-top-left-radius: 50% 90%; border-top-right-radius: 50% 90%; border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%;&#125;.innerRightEye::after &#123; content: ""; position: absolute; bottom: -1px; left: 4px; /* 月牙眼球内部轮廓 */ width: 10px; height: 13px; border: 1px solid #000; border-top-left-radius: 50% 100%; border-top-right-radius: 35% 80%;&#125;.fix &#123; position: absolute; top: 17px; width: 4px; height: 4px; border: 1px solid #000; border-radius: 50%;&#125;.fix:after &#123; content: ""; position: absolute; top: 0; left: 14px; width: 4px; height: 4px; border: 1px solid #000; border-radius: 50%;&#125; 嘴 1234567891011121314151617&lt;!-- 上嘴唇 --&gt;&lt;div class="mouthTopContainer"&gt; &lt;div class="mouthTop"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 下嘴唇--&gt;&lt;div class="mouthBottomContainer"&gt; &lt;div class="mouthBottom"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 嘴唇上下层次感-咬合部位 --&gt;&lt;div class="lispContainer"&gt; &lt;div class="lips"&gt; &lt;div class="lipShadow left"&gt; &lt;/div&gt; &lt;div class="lipShadow right"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* QQ head -&gt; mouth */.mouthTopContainer &#123; /* 定位 */ position: absolute; top: 120px; left: 39px; width: 158px; height: 29px; overflow: hidden; /* 隐藏超出部分 */&#125;.mouthTop &#123; /* 上嘴唇轮廓 */ position: absolute; top: 0; left: 0; width: 158px; height: 34px; border: 1px solid #000; border-top-left-radius: 45% 34px; border-top-right-radius: 45% 34px;&#125;.mouthBottomContainer &#123; position: absolute; top: 146px; left: 39px; width: 158px; height: 15px; overflow: hidden; /* 隐藏超出部分 */&#125;.mouthBottom &#123; position: absolute; top: -4px; left: 0; width: 158px; height: 24px; border: 1px solid #000; border-top: none; border-bottom-left-radius: 45% 24px; border-bottom-right-radius: 45% 24px;&#125;/* 嘴唇上下层次感-咬合部位 */.lispContainer &#123; /* 定位 */ position: absolute; top: 146px; left: 60px; width: 116px; height: 24px;&#125;.lips &#123; position: absolute; top: 0; left: 0; width: 116px; height: 24px; border: 1px solid #ffa600; border-bottom-left-radius: 50% 100%; border-bottom-right-radius: 50% 100%;&#125; 基本 head 轮廓就是这样了，最后在把右眼眼球部分上个色，来进行层叠覆盖隐藏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.innerRightEye &#123; position: absolute; top: 20px; left: 8px; /* 月牙眼球外轮廓 */ width: 18px; height: 24px; /* border: 1px solid #000; */ border-top-left-radius: 50% 90%; border-top-right-radius: 50% 90%; border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%; background: black; box-shadow: 0 -1px 2px black;&#125;.innerRightEye::after &#123; content: ""; position: absolute; bottom: -1px; left: 4px; /* 月牙眼球内部轮廓 */ width: 10px; height: 13px; /* border: 1px solid #000; */ border-top-left-radius: 50% 100%; border-top-right-radius: 35% 80%; background: white;&#125;.fix &#123; position: absolute; top: 19px; width: 4px; height: 4px; /* border: 1px solid #000; */ border-radius: 50%; background: black;&#125;.fix:after &#123; content: ""; position: absolute; top: 0; left: 14px; width: 4px; height: 4px; /* border: 1px solid #000; */ border-radius: 50%; background: black;&#125; 接下来 开始绘制 QQ 的 body 部分，老样子对 body 进行层次结构划分：围巾、围巾尾、内轮廓、外轮廓 123456789101112131415&lt;!-- 身体 --&gt;&lt;div class="body"&gt; &lt;!-- 内轮廓 --&gt; &lt;div class="innerWrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 外轮廓 --&gt; &lt;div class="outerWrapper"&gt; &lt;div class="outer"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 围巾 --&gt; &lt;div class="scarf"&gt;&lt;/div&gt; &lt;!-- 围巾尾 --&gt; &lt;div class="scarfEnd"&gt;&lt;/div&gt;&lt;/div&gt; 先各个容器位置布局好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* QQ body */.body &#123; /* body 容器定位 */ position: absolute; top: 135px; left: 48px; width: 326px; height: 300px; /* border: 1px solid #000; */&#125;/* QQ body -&gt; scarf */.scarf &#123; position: absolute; top: -2px; left: 34px; width: 258px; height: 110px; border: 1px solid #000; border-top: none;&#125;/* QQ body -&gt; scarfEnd */.scarfEnd &#123; position: absolute; left: 74px; top: 90px; width: 52px; height: 64px; border: 3px solid black;&#125;/* QQ body -&gt; innerWrapper */.innerWrapper &#123; /* innerWrapper 容器定位 */ position: absolute; left: 30px; top: 76px; width: 280px; height: 200px; border: 1px solid #000;&#125;/* QQ body -&gt; outerWrapper */.outerWrapper &#123; /* outerWrapper 容器定位 */ position: absolute; top: 54px; overflow: hidden; width: 262px; left: 32px; height: 250px; border: 1px solid #000;&#125; 轮廓线条修正 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* QQ body */.body &#123; /* body 容器定位 */ position: absolute; top: 135px; left: 48px; width: 326px; height: 300px; /* border: 1px solid #000; */&#125;/* QQ body -&gt; scarf */.scarf &#123; position: absolute; top: -2px; left: 34px; width: 258px; height: 110px; border: 1px solid #000; border-top-left-radius: 30px 34px; border-top-right-radius: 38px 34px; border-bottom-left-radius: 50% 76px; border-bottom-right-radius: 50% 76px; border-top: none;&#125;/* QQ body -&gt; scarfEnd */.scarfEnd &#123; position: absolute; left: 74px; top: 90px; width: 52px; height: 64px; border: 3px solid black; border-bottom-left-radius: 50% 43%; border-bottom-right-radius: 15px; border-top-left-radius: 20% 57%;&#125;/* QQ body -&gt; innerWrapper */.innerWrapper &#123; /* innerWrapper 容器定位 */ position: absolute; left: 30px; top: 76px; width: 280px; height: 200px; overflow: hidden;&#125;.inner &#123; position: absolute; left: 25px; top: -71px; width: 218px; height: 210px; border: 1px solid #000; border-radius: 50%;&#125;/* QQ body -&gt; outerWrapper */.outerWrapper &#123; /* outerWrapper 容器定位 */ position: absolute; top: 54px; overflow: hidden; width: 262px; left: 32px; height: 250px;&#125;.outer &#123; position: absolute; top: -84px; width: 260px; height: 250px; border: 1px solid #000; border-radius: 125px;&#125; 大致轮廓基本已经出来了，还有一些内部线条，等后面在来慢慢绘制。 接下来我们来绘制 hand 部分，安装老路子层次结构划分：左手、右手； 手的样子需要通过两个 div 进行整合才能绘制出来，所以再次划分： 左手上、左手下、右手上、右手下 123456789101112131415&lt;!-- 手 --&gt;&lt;div class="handWrapper"&gt; &lt;div class="leftHandTopContainer"&gt; &lt;div class="leftHandTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="leftHandBottomContainer"&gt; &lt;div class="leftHandBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightHandTopContainer"&gt; &lt;div class="rightHandTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightHandBottomContainer"&gt; &lt;div class="rightHandBottom"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* QQ handWrapper */.handWrapper &#123; /* 定位手的起始点 */ position: absolute; top: 219px; left: 7px;&#125;/* QQ handWrapper -left */.leftHandTopContainer &#123; /* 定位 */ position: absolute; top: 55px; left: 50px; width: 118px; height: 26px; border: 1px solid #000; transform-origin: bottom left; transform: rotate(-70deg);&#125;.leftHandBottomContainer &#123; /* 定位 */ position: absolute; top: 78px; left: 50px; width: 100px; height: 30px; border: 1px solid #000; transform-origin: top left; transform: rotate(-70deg);&#125;/* QQ handWrapper -right */.rightHandTopContainer &#123; /* 定位 */ position: absolute; top: 47px; left: 240px; width: 118px; height: 34px; border: 1px solid #000; transform-origin: bottom right; transform: rotate(65deg);&#125;.rightHandBottomContainer &#123; /* 定位 */ position: absolute; top: 81px; left: 248px; width: 110px; height: 58px; border: 1px solid #000; transform-origin: top right; transform: rotate(90deg);&#125; 线条轮廓修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* QQ handWrapper */.handWrapper &#123; /* 定位手的起始点 */ position: absolute; top: 219px; left: 7px;&#125;/* QQ handWrapper -left */.leftHandTopContainer &#123; /* 定位 */ position: absolute; top: 55px; left: 50px; width: 118px; height: 26px; /* border: 1px solid #000; */ transform-origin: bottom left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandTop &#123; /* 上半部分 */ width: 128px; height: 54px; border: 1px solid #050346; border-top-left-radius: 44% 38px; border-top-right-radius: 56% 33px;&#125;.leftHandBottomContainer &#123; /* 定位 */ position: absolute; top: 78px; left: 50px; width: 100px; height: 30px; /* border: 1px solid #000; */ transform-origin: top left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandBottom &#123; position: absolute; top: -26px; width: 128px; height: 44px; border: 1px solid #050346; border-bottom-left-radius: 48% 20px; border-bottom-right-radius: 52% 23px;&#125;/* QQ handWrapper -right */.rightHandTopContainer &#123; /* 定位 */ position: absolute; top: 47px; left: 240px; width: 118px; height: 34px; /* border: 1px solid #000; */ transform-origin: bottom right; transform: rotate(65deg); overflow: hidden;&#125;.rightHandTop &#123; position: absolute; left: -30px; width: 148px; height: 54px; border: 1px solid #050346; border-top-right-radius: 41% 54px; border-top-left-radius: 59% 48px;&#125;.rightHandBottomContainer &#123; /* 定位 */ position: absolute; top: 81px; left: 248px; width: 110px; height: 58px; /* border: 1px solid #000; */ transform-origin: top right; transform: rotate(90deg); overflow: hidden;&#125;.rightHandBottom &#123; position: absolute; top: 1px; left: 38px; width: 68px; height: 28px; border: 1px solid #000; border-bottom-right-radius: 100% 40px;&#125; 是不是漂亮很多了， 那快点把脚的部分也完成吧,和手的结构基本类似。 123456789101112131415&lt;!-- 脚 --&gt;&lt;div class="footWrapper"&gt; &lt;div class="leftFootTopWrapper"&gt; &lt;div class="leftFootTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="leftFootBottomWrapper"&gt; &lt;div class="leftFootBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightFootTopWrapper"&gt; &lt;div class="rightFootTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightFootBottomWrapper"&gt; &lt;div class="rightFootBottom"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 基础位置布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* QQ footerWrapper */.footWrapper &#123; /* 定位起始点 */ position: absolute; top: 292px; left: 80px; width: 300px; height: 80px; border: 1px solid #000;&#125;/* QQ footerWrapper -&gt; left */.leftFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 16px; left: -1px; width: 130px; height: 37px; border: 1px solid #000;&#125;.leftFootBottomWrapper &#123; position: absolute; top: 52px; left: -1px; width: 130px; height: 38px; border: 1px solid #000;&#125;/* QQ footerWrapper -&gt; right */.rightFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 22px; left: 134px; width: 130px; height: 38px; border: 1px solid #000;&#125;.rightFootBottomWrapper &#123; position: absolute; top: 52px; left: 134px; width: 134px; height: 38px; border: 1px solid #000;&#125; 轮廓调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* QQ footerWrapper */.footWrapper &#123; /* 定位起始点 */ position: absolute; top: 292px; left: 80px; width: 300px; height: 80px; /* border: 1px solid #000; */&#125;/* QQ footerWrapper -&gt; left */.leftFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 16px; left: -1px; width: 130px; height: 37px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootTop &#123; position: absolute; top: -10px; left: 3px; width: 120px; height: 60px; border: 4px solid black; border-top-left-radius: 80% 70%;&#125;.leftFootBottomWrapper &#123; position: absolute; top: 52px; left: -1px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 44%; border-top-right-radius: 50% 44%; border-bottom-left-radius: 50% 56%; border-bottom-right-radius: 50% 56%;&#125;/* QQ footerWrapper -&gt; right */.rightFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 22px; left: 134px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootTop &#123; position: absolute; top: 0px; left: 4px; width: 120px; height: 60px; border: 4px solid black; border-top-right-radius: 32% 65%;&#125;.rightFootBottomWrapper &#123; position: absolute; top: 52px; left: 134px; width: 134px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 56%; border-top-right-radius: 50% 56%; border-bottom-left-radius: 50% 44%; border-bottom-right-radius: 50% 44%;&#125; 基本整体框架结构就出来了，开始上色吧。上色的过程可以帮助我们调整 z-index，也就是各个模块的重叠层次，遮盖了一些无用的线条和框角。 head 开始 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/* QQ head */.head &#123; position: absolute; top: 18px; left: 96px; width: 234px; height: 185px; border: 1px solid #000; border-top-left-radius: 117px 117px; border-top-right-radius: 117px 117px; border-bottom-left-radius: 117px 68px; border-bottom-right-radius: 117px 68px; background: #000;&#125;/* QQ head -&gt; eye */.eye &#123; position: absolute; width: 44px; height: 66px; border: 1px solid #000; border-radius: 50% 50%; background: #fff;&#125;.left.eye &#123; left: 62px; top: 50px;&#125;.right.eye &#123; left: 132px; top: 50px;&#125;.innerLeftEye &#123; position: absolute; top: 20px; left: 20px; width: 18px; height: 24px; border-radius: 50%; border: 1px solid #000; background: #000;&#125;.innerLeftEye::after &#123; content: ""; position: absolute; top: 6px; left: 9px; width: 6px; z-index: 11; height: 8px; /* border: 1px solid #000; */ border-radius: 50%; background: #fff;&#125;.innerRightEye &#123; position: absolute; top: 20px; left: 8px; /* 月牙眼球外轮廓 */ width: 18px; height: 24px; /* border: 1px solid #000; */ border-top-left-radius: 50% 90%; border-top-right-radius: 50% 90%; border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%; background: black; box-shadow: 0 -1px 2px black;&#125;.innerRightEye::after &#123; content: ""; position: absolute; bottom: -1px; left: 4px; /* 月牙眼球内部轮廓 */ width: 10px; height: 13px; /* border: 1px solid #000; */ border-top-left-radius: 50% 100%; border-top-right-radius: 35% 80%; background: #fff;&#125;.fix &#123; position: absolute; top: 19px; width: 4px; height: 4px; /* border: 1px solid #000; */ border-radius: 50%; background: #000;&#125;.fix:after &#123; content: ""; position: absolute; top: 0; left: 14px; width: 4px; height: 4px; /* border: 1px solid #000; */ border-radius: 50%; background: black;&#125;/* QQ head -&gt; mouth */.mouthTopContainer &#123; /* 定位 */ position: absolute; top: 120px; left: 39px; z-index: 1; width: 158px; height: 29px; overflow: hidden; /* 隐藏超出部分 */&#125;.mouthTop &#123; /* 上嘴唇轮廓 */ position: absolute; top: 0; left: 0; z-index: 1; width: 158px; height: 34px; border: 1px solid #ffa600; border-top-left-radius: 45% 34px; border-top-right-radius: 45% 34px; background: #ffa600;&#125;.mouthBottomContainer &#123; position: absolute; top: 146px; left: 39px; z-index: 1; width: 158px; height: 15px; overflow: hidden; /* 隐藏超出部分 */&#125;.mouthBottom &#123; position: absolute; top: -4px; left: 0; z-index: 1; width: 158px; height: 24px; border: 1px solid #ffa600; border-top: none; border-bottom-left-radius: 45% 24px; border-bottom-right-radius: 45% 24px; background: #ffa600;&#125;/* 嘴唇上下层次感-咬合部位 */.lispContainer &#123; /* 定位 */ position: absolute; top: 146px; left: 60px; width: 116px; height: 24px;&#125;.lips &#123; position: absolute; top: 0; left: 0; width: 116px; height: 24px; border: 1px solid #ffa600; border-bottom-left-radius: 50% 100%; border-bottom-right-radius: 50% 100%; background: #ffa600;&#125; body 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* QQ body */.body &#123; /* body 容器定位 */ position: absolute; top: 135px; left: 48px; width: 326px; height: 300px; /* border: 1px solid #000; */&#125;/* QQ body -&gt; scarf */.scarf &#123; position: absolute; top: -2px; left: 34px; z-index: 5; width: 258px; height: 110px; border: 1px solid #000; border-top-left-radius: 30px 34px; border-top-right-radius: 38px 34px; border-bottom-left-radius: 50% 76px; border-bottom-right-radius: 50% 76px; border-top: none; background: #fb0009;&#125;/* QQ body -&gt; scarfEnd */.scarfEnd &#123; position: absolute; left: 74px; top: 90px; width: 52px; height: 64px; border: 3px solid black; border-bottom-left-radius: 50% 43%; border-bottom-right-radius: 15px; border-top-left-radius: 20% 57%; background: #fb0009;&#125;/* QQ body -&gt; innerWrapper */.innerWrapper &#123; /* innerWrapper 容器定位 */ position: absolute; left: 30px; top: 76px; width: 280px; height: 200px; overflow: hidden;&#125;.inner &#123; position: absolute; left: 25px; top: -71px; width: 218px; height: 210px; border: 1px solid #000; border-radius: 50%; background: #fff;&#125;/* QQ body -&gt; outerWrapper */.outerWrapper &#123; /* outerWrapper 容器定位 */ position: absolute; top: 54px; overflow: hidden; width: 262px; left: 32px; height: 250px;&#125;.outer &#123; position: absolute; top: -84px; width: 260px; height: 250px; border: 1px solid #000; border-radius: 125px; background: #000;&#125; 上色后你会发现，有的图层显示先后顺序不对，需要调整下先后顺序。 head &gt; body body 里（scafEnd &gt; inner &gt; outer） hand 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* QQ handWrapper -left */.leftHandTopContainer &#123; /* 定位 */ position: absolute; top: 55px; left: 50px; width: 118px; height: 26px; /* border: 1px solid #000; */ transform-origin: bottom left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandTop &#123; /* 上半部分 */ width: 128px; height: 54px; border: 1px solid #050346; border-top-left-radius: 44% 38px; border-top-right-radius: 56% 33px; background: #000;&#125;.leftHandBottomContainer &#123; /* 定位 */ position: absolute; top: 78px; left: 50px; width: 100px; height: 30px; /* border: 1px solid #000; */ transform-origin: top left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandBottom &#123; position: absolute; top: -26px; width: 128px; height: 44px; border: 1px solid #050346; border-bottom-left-radius: 48% 20px; border-bottom-right-radius: 52% 23px; background: #000;&#125;/* QQ handWrapper -right */.rightHandTopContainer &#123; /* 定位 */ position: absolute; top: 47px; left: 240px; width: 118px; height: 34px; /* border: 1px solid #000; */ transform-origin: bottom right; transform: rotate(65deg); overflow: hidden;&#125;.rightHandTop &#123; position: absolute; left: -30px; width: 148px; height: 54px; border: 1px solid #050346; border-top-right-radius: 41% 54px; border-top-left-radius: 59% 48px; background: #000;&#125;.rightHandBottomContainer &#123; /* 定位 */ position: absolute; top: 81px; left: 248px; width: 110px; height: 58px; /* border: 1px solid #000; */ transform-origin: top right; transform: rotate(90deg); overflow: hidden;&#125;.rightHandBottom &#123; position: absolute; top: 1px; left: 38px; width: 68px; height: 28px; border: 1px solid #000; border-bottom-right-radius: 100% 40px; background: #000;&#125; footer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* QQ footerWrapper */.footWrapper &#123; /* 定位起始点 */ position: absolute; top: 292px; left: 80px; width: 300px; height: 80px; /* border: 1px solid #000; */&#125;/* QQ footerWrapper -&gt; left */.leftFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 16px; left: -1px; width: 130px; height: 37px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootTop &#123; position: absolute; top: -10px; left: 3px; width: 120px; height: 60px; border: 4px solid black; border-top-left-radius: 80% 70%; background: #ff9c00;&#125;.leftFootBottomWrapper &#123; position: absolute; top: 52px; left: -1px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 44%; border-top-right-radius: 50% 44%; border-bottom-left-radius: 50% 56%; border-bottom-right-radius: 50% 56%; background: #ff9c00;&#125;/* QQ footerWrapper -&gt; right */.rightFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 22px; left: 134px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootTop &#123; position: absolute; top: 0px; left: 4px; width: 120px; height: 60px; border: 4px solid black; border-top-right-radius: 32% 65%; background: #ff9c00;&#125;.rightFootBottomWrapper &#123; position: absolute; top: 52px; left: 134px; width: 134px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 56%; border-top-right-radius: 50% 56%; border-bottom-left-radius: 50% 44%; border-bottom-right-radius: 50% 44%; background: #ff9c00;&#125; 到了这里基本完成了 90% 了， 剩下的就是线条优化，使 QQ 看起来更有层次感、立体感。 嘴唇 嘴巴的形状不够性感、立体；绘制一个斜边三角形，修复嘴唇的层次感。 绘制这样一个斜边三角形，步骤分解如图所示： 先是绘制一个普通三角形，通过逆时针旋转得到一个修复三角形，那么相对称的修复三角形可以通过使用 rotateY，绕着 Y 轴旋转 180 度，来得到。 12345678&lt;!-- 嘴唇上下层次感 --&gt;&lt;div class="lispContainer"&gt; &lt;div class="lips"&gt; &lt;!-- 左右上下嘴唇咬合阴影 --&gt; &lt;div class="lipShadow left"&gt;&lt;/div&gt; &lt;div class="lipShadow right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 嘴唇上下层次感-咬合部位 */.lispContainer &#123; /* 定位 */ position: absolute; top: 146px; left: 60px; width: 116px; height: 24px;&#125;.lips &#123; position: absolute; top: 0; left: 0; width: 116px; height: 24px; border: 1px solid #ffa600; border-bottom-left-radius: 50% 100%; border-bottom-right-radius: 50% 100%; background: #ffa600;&#125;.lipShadow &#123; position: absolute; width: 0px; height: 0px; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-right: 8px solid black; transform-origin: top right; transform: rotate(-60deg); z-index: 2;&#125;.lipShadow.left &#123; top: 4px; left: -12px; transform: rotate(-60deg);&#125;.lipShadow.right &#123; top: 4px; left: 111px; transform: rotate(60deg) rotateY(180deg);&#125; 围巾 围脖竟然没折痕，不立体； 通过绘制一个“小尾巴”来进行美化 1234border-right: 6px solid black;width: 100px;height: 70px;border-bottom-right-radius: 70px 70px; 当对一个角应用圆角样式，如果这个角相邻的两个 border 一个有定义而一个无定义，那么绘制的结果就是由粗到细的“小尾巴了”。[在整个绘制过程中，同一个图形它的绘制方法有很多种，例如一个矩形可以用 width x height 构成，也可以由 border x height(width)构成，甚至可以由 border 组合(width = height = 0)构成，根据情况选择吧。] 12345678910&lt;!-- 围巾 --&gt;&lt;div class="scarf"&gt; &lt;div class="scarfShadow"&gt;&lt;/div&gt; &lt;div class="scarfShadowRight"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 围巾尾 --&gt;&lt;div class="scarfEnd"&gt; &lt;div class="scarfEndShadow"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* QQ body -&gt; scarf */.scarf &#123; position: absolute; top: -2px; left: 34px; z-index: 5; width: 258px; height: 110px; border: 4px solid #000; border-top-left-radius: 30px 34px; border-top-right-radius: 38px 34px; border-bottom-left-radius: 50% 76px; border-bottom-right-radius: 50% 76px; border-top: none; background: #fb0009;&#125;.scarfShadowLeft &#123; position: absolute; top: 0px; left: 6px; width: 60px; height: 70px; /* border: 4px solid #000; */ border-top: 6px solid #000; border-top-left-radius: 90px 120px; border-top-right-radius: 30px 30px; transform: rotate(-79deg);&#125;.scarfShadowRight &#123; position: absolute; top: 8px; left: 143px; width: 100px; height: 70px; /* border: 4px solid #000; */ border-right: 6px solid black; width: 100px; border-bottom-right-radius: 70px 70px; border-right: 6px solid black;&#125;/* QQ body -&gt; scarfEnd */.scarfEnd &#123; position: absolute; left: 74px; top: 90px; width: 52px; height: 64px; border: 3px solid black; border-bottom-left-radius: 50% 43%; border-bottom-right-radius: 15px; border-top-left-radius: 20% 57%; background: #fb0009; z-index: 4;&#125;.scarfEndShadow &#123; position: absolute; top: 6px; left: 12px; width: 20px; height: 20px; /* border: 4px solid #000; */ border-top: 6px solid #000; border-top-left-radius: 30px 30px; transform-origin: top right; transform: skewX(4deg) scaleY(1.5) rotate(-60deg);&#125; 脚 也是通过绘制小尾巴来进行美化 12345678910111213141516171819&lt;!-- 脚 --&gt;&lt;div class="footWrapper"&gt; &lt;div class="leftFootTopWrapper"&gt; &lt;div class="leftFootTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="leftFootBottomWrapper"&gt; &lt;div class="leftFootBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 脚趾间隔线条 --&gt; &lt;div class="toe left"&gt;&lt;/div&gt; &lt;div class="rightFootTopWrapper"&gt; &lt;div class="rightFootTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightFootBottomWrapper"&gt; &lt;div class="rightFootBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 脚趾间隔线条 --&gt; &lt;div class="toe right"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* QQ footerWrapper */.footWrapper &#123; /* 定位起始点 */ position: absolute; top: 292px; left: 80px; width: 300px; height: 80px; /* border: 1px solid #000; */&#125;.toe &#123; position: absolute; width: 25px; height: 20px; /* border: 4px solid #000; */ border-top: 4px solid black; border-top: 4px solid black; border-top-right-radius: 30px 30px; border-top-left-radius: 10px 10px; transform-origin: top left; z-index: 10;&#125;/* QQ footerWrapper -&gt; left */.leftFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 16px; left: -1px; width: 130px; height: 37px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootTop &#123; position: absolute; top: -10px; left: 3px; width: 120px; height: 60px; border: 4px solid black; border-top-left-radius: 80% 70%; background: #ff9c00;&#125;.toe.left &#123; top: 50px; left: 2px; transform: rotate(-45deg);&#125;.leftFootBottomWrapper &#123; position: absolute; top: 52px; left: -1px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 44%; border-top-right-radius: 50% 44%; border-bottom-left-radius: 50% 56%; border-bottom-right-radius: 50% 56%; background: #ff9c00;&#125;/* QQ footerWrapper -&gt; right */.rightFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 22px; left: 134px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootTop &#123; position: absolute; top: 0px; left: 4px; width: 120px; height: 60px; border: 4px solid black; border-top-right-radius: 32% 65%; background: #ff9c00;&#125;.toe.right &#123; top: 50px; left: 264px; transform: rotate(45deg) rotateY(180deg);&#125;.rightFootBottomWrapper &#123; position: absolute; top: 52px; left: 134px; width: 134px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 56%; border-top-right-radius: 50% 56%; border-bottom-left-radius: 50% 44%; border-bottom-right-radius: 50% 44%; background: #ff9c00;&#125; 大功告成，一个生动的 QQ 企鹅就绘制完了～ 介绍下这个过程中几个比较典型的图形绘制方法： 1、企鹅的眼睛：椭圆，直接设置 border-radius:50% 50%; 即可[因为宽高分别为 44px 和 66px，所以也可以这样设定：border-radius: 22px / 33px] 2、围脖的尾部：一个圆角各异的矩形，所以这里需要对几个角分别设定 border-radius，微调的结果为 123border-bottom-left-radius: 50% 43%;border-bottom-right-radius: 15px;border-top-left-radius: 20% 57%; 3、企鹅的胳膊：手的绘制较为麻烦一点，可以分为上下两个部分，将绘制的结果拼接到一起。那么对于不需要的部分怎么办呢？我们可以将上(下)部分放到一个 div(container)中，利用 overflow:hidden 的属性来截取所要的部分。绘制复杂图形的时候常用的方法就是切割和拼接，将图形切割成一个个简单的小块，通过层叠和旋转变化进行组合。 使用 transform:rotate(deg)的时候，优先设定 transform-origin 属性，会比较方便。设定的点作为中心点，整个图形绕着这个点进行角度变化。例如：transform-origin:bottom left， 使用左下角作为原点。也可以使用具体的像素值和百分比。 在基本的框架线条中比非常多的使用了 border-radius 用于构造各种曲线条，小企鹅是圆圆胖胖的，:) 本文参考 源码]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo + Github 搭建个人静态博客]]></title>
    <url>%2F2018%2F05%2F19%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[使用 Hexo 搭建静态博客什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 12345678910111213141516171819npm install -g hexo-cli# 安装是否成功 ~/Life  hexo version  14:35:29hexo-cli: 1.1.0os: Darwin 17.5.0 darwin x64http_parser: 2.8.0node: 8.11.1v8: 6.2.414.50uv: 1.19.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2oicu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 工具都备好，开始搭建博客请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件,⚠️ 要空文件夹哦～ 1234# 初始化hexo项目仓库$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 初始化完成后，指定文件夹的目录如下： 1234567891011.├── _config.yml // 网站配置信息├── package.json // 应用程序的信息├── scaffolds // 模版 文件夹│ ├── draft.md│ ├── page.md│ └── post.md├── source // 资源文件夹│ └── _posts└── themes // 主题 └── landscape 到这里一个最基础的博客就搭建出来了，让我们运行起来: 1hexo server 与GitHub关联上GitHub Page 实现方式，目前我知道的是三种： 创建一个跟你github账号相关的仓库，github默认给你的域名就是 [username].github.io 创建仓库，在 setting 中通过设置 Github page 的方式 创建 gh-pages 分支的方式 这三种方式其实属于两种基本的 GitHub Pages 类型：用户/组织 Pages 和 项目 Pages。 用户/组织 Pages 存在于一个特定的 GitHub Pages 文件专有库中。你将使用用户名来命名这个库，比如 twitchbody.github.io；master分支 上的内容将用于构建和发布你的 GitHub Pages 网页。 不像用户和组织的 Pages，项目 Pages 是作为一个项目保存在同一个库中, 以作为项目介绍和文档存在。gh-pages分支用来构建和发布项目 Pages 网站。如果没有 自定义的域名，项目 Pages 网站将服务在用户 Pages 网站的子域名下：username.github.io/projectName。 这里我使用方式3: 建立一个项目 Pages，你需要在你的库中新建一个新的 orphan 分支（一个与现存分支没有共同的历史的分支）。 1234567# 进入项目$ cd pycoder-hexo# 创建分支$ git checkout --orphan gh-pages# 清除分支所有内容，保证是一个干净的分支$ git rm -rf . 然后，创建 index.html 文件做测试: 123456# 创建$ echo &quot;My Page!&quot; &gt; index.html$ git add .$ git commit -m &quot;my first page&quot;$ git push origin gh-pages 接着，进入setting，设置下 Github page: 使用自定义域名，需要你到域名服务商里进行增加一个域名解析： ⚠️, 这里要是没有自定义域名，到时候部署 hexo 生成的静态文件的时候，站点访问静态资源会出现 404错误，你会发现路径出现问题。 打造超酷的博客安装主题我选择的是比较火和流行的 Next主题： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题需要在 _config.yml文件进行配置： 1234# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 设定主题Next是一个主题，三种外观，选您所好！挑选你看的顺眼的外观。 12 配置站点相关信息的配置, 可以在 _config.yml 中修改大部份的配置。了解相关配置，可以参考 配置文档，进行你的基础信息设置。 指令之前我们初始化项目的时候已经使用过2个 hexo 指令了 hexo init pyCoder 和 hexo version, 接下来我们详细了解其他的hexo指令，想要hexo玩出花，指令是必须的～ new新建一篇文章 1hexo new [layout] &lt;title&gt; 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate生成静态文件。 123456789hexo generate# 简写hexo g# 文件生成后立即部署网站hexo generate -d // (-d,--deploy)# 监视文件变动hexo generate -w // (-w, --watch) publish发表草稿。 1hexo publish [layout] &lt;filename&gt; server启动服务器。默认情况下，访问网址为： http://localhost:4000/。 12345678910hexo serve# 重设端口hexo serve -p 8080 // (-p, --port)# 只使用静态文件hexo serve -s // (-s, --static)# 启动日记记录，使用覆盖记录格式hexo serve -l // (-l, --log) deploy部署网站。 123456hexo deploy# 简写hexo d# 部署之前预先生成静态文件 hexo deploy -g // (-g, --generate) render渲染文件。 1234hexo render &lt;file1&gt; [file2] ...# 设置输出路径 hexo render &lt;file1&gt; [file2] -o path // (-o, --output) migrate从其他博客系统 迁移内容 1hexo migrate &lt;type&gt; clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。 1hexo clean 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1hexo list &lt;type&gt; 列出网站资料。 version显示 Hexo 版本。 1hexo version 安全模式1hexo safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 Hexo GitHub 的 issue 上 。 简洁模式1hexo --silent 隐藏终端信息。 自定义配置文件的路径1hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿1hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
