<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Echo]]></title>
    <url>%2F2018%2F05%2F21%2Fecho-520%2F</url>
    <content type="text"><![CDATA[Echo这是一个网络应用程序，与我的女朋友一起庆祝 5 月 20 日（意思是“我爱你”）。 ;P 它受 iMessage 中名为 echo 的消息效果的启发。 只是让你开心。 嗯，这就是此作者的原话，满满的撒狗粮 🐶🐶🐶，但是此程序还是很有趣的对不对～所以还是拉下代码，悄悄的 👀 一波（毕竟单身汪，周末也没什么事） 预览 demo 将学到的知识点 单一 div 气泡绘制 随机大小位置 动画效果 内存回收 气泡绘制可以看出它是由一个椭圆和一个小尾巴构成。 如何绘制下这个小尾巴？ 先看下这篇文章了解下使用CSS3绘制图形基本原理 12345width: 10rem;height: 10rem;background-color: orangered;border-left: 1rem solid orange;border-bottom-left-radius: 10rem 7rem; 看此上，将背景色取掉；是不是一个小尾巴就出来了，缩小下尺寸，汽泡的小尾巴就就出来了～这里我们通过伪类元素来绘制气泡的小尾巴。 随机大小位置气泡是绝对定位的，控制随机出现的位置，其实就是控制 left和 top值。 先获取当前可视窗口尺寸 控制气泡出现的在可视窗口的范围内， left 和 top 小于可视窗口宽高的值 大小，使用 CSS3 里的 transform 属性的 scale() 来控制（肯定不能比本身的小） 123const left = Math.ceil(Math.random() * 0.9 * screenSize.width)const top = Math.ceil(Math.random() * 0.9 * screenSize.width)const scale = 1 + Math.random(); // 缩放值 内存回收内存回收实现原理，good 作为是否回收的标志（全 false 进行回收）。整个流程就是每一个消息 good 默认为 true, 当某条消息完成了消失动画以后，就会将 good 状态变为 false; 然后将固定的第一条消息以外的全部消息中的 good 提取出来。我们的最终目的是判断当前提取出来的新数组里是否还存在处于展示状态的消息，无论消息量有多少，只需要判断是否至少有一个 good 状态为 true即可，直到全部消息的 good 状态都为 false了，我们再进行内存回收 ♻️，也就是对 msgs 重置。 内存回收的实现: 123456const hasMsgs = this.msgs .slice(1) .map((&#123; good &#125;) =&gt; good) .reduce((left, right) =&gt; left || right); // 找出任意一个为 true 的状态if (!hasMsgs) this.msgs.splice(1); 参考DEMO LicenseMIT Licensed.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS 学习记录]]></title>
    <url>%2F2018%2F05%2F19%2Fangularjs-learning-record%2F</url>
    <content type="text"><![CDATA[AngularJS 初识篇Angular CLI 安装12345678910111213141516# 全局安装$ npm install -g @angular/cli# 检验安装是否成功,出现以下图标就说明成功了$ ng -v _ _ ____ _ ___ / \ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \ | &apos;_ \ / _` | | | | |/ _` | &apos;__| | | | | | | / ___ \| | | | (_| | |_| | | (_| | | | |___| |___ | |/_/ \_\_| |_|\__, |\__,_|_|\__,_|_| \____|_____|___| |___/Angular CLI: 1.7.4Node: 8.11.1OS: darwin x64Angular: 初始化新项目1234567# 创建项目成功后，会自动 npm install$ ng new helloAngular(project name)# 启动项目（开启本地服务）$ ng serve// or 启动项目，并打开浏览器 （--open or -o）$ ng serve --open ng serve指令参数含义ng serve 命令会启动开发服务器，监听文件变化，并在修改这些文件时重新构建此应用。 --open or -o 自动打开浏览器并访问 --prod 指定为生产模式，会自动打包项目 创建我的第一个组件Angular CLI 命令行工具，自带指令集，可以让我们快速开发和遵循 Angular 的开发风格指南。 1234# 创建组件 组件名需要遵循大驼峰命名规则$ ng generate component ComponentName// or 简写$ ng g c ComponentName Angular三大核心概念Angular最核心的概念是“组件化”,新版本的 Angular 来说，一切都是围绕着“组件化”展开的，组件是 Angular 的核心概念模型。 Component Module Route 以下是一个最简单的 Angular 组件定义： 12345678910import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss']&#125;)export class AppComponent &#123; title = 'Jun ting';&#125; @Component：这是一个 Decorator（装饰器），其作用类似于 Java 里面的注解。Decorator 这个语言特性目前（2017-10）处于 Stage 2（草稿）状态，还不是 ECMA 的正式规范。 selector：组件的标签名，外部使用者可以这样来使用这个组件：。默认情况下，ng 命令生成出来的组件都会带上一个 app 前缀，如果你不喜欢，可以在 angular-cli.json 里面修改 prefix 配置项，设置为空字符串将会不带任何前缀。 templateUrl：引用外部的 HTML 模板。如果你想直接编写内联模板，可以使用 template，支持 ES6 引入的“模板字符串”写法。 styleUrls：引用外部 CSS 样式文件，这是一个数组，也就意味着可以引用多份 CSS 文件。 export class AppComponent：这是 ES6 里面引入的模块和 class 定义方式。 把 CSS 预编译器改成 SASS@angular/cli 创建项目的时候没有自动使用 SASS 作为预编译器，我们需要自己手动修改一些配置文件,请按照以下步骤依次修改： 1、 angular-cli.json 里面的 styles.css 后缀改成 .scss 12345678910111213141516171819"apps": [ &#123; "root": "src", "outDir": "dist", "assets": [ "assets", "favicon.ico" ], "index": "index.html", "main": "main.ts", "polyfills": "polyfills.ts", "test": "test.ts", "tsconfig": "tsconfig.app.json", "testTsconfig": "tsconfig.spec.json", "prefix": "app", // 这里 "styles": [ "styles.scss" ], 后面再使用 ng g c *** 自动创建组件的时候，默认就会生成 .scss 后缀的样式文件了。 2、 angular-cli.json 里面的 styleExt 改成 .scss 1234"defaults": &#123; "styleExt": "scss", "component": &#123;&#125;&#125; 3、 src 下面.css后缀的文件全修改为.scss 引入 bootstrap、font-awesome安装 bootstrap、font-awesome 依赖 12345# bootstrapnpm install bootstrap --save# font-awesomenpm install font-awesome --save 在 style.scss 引入 bootstrap、font-awesome 的 css 12@import "~bootstrap/dist/css/bootstrap.min.css";@import "~font-awesome/css/font-awesome.min.css"; AngularJS 模板语法 模板是编写 Angular 组件最重要的一环，你至少需要深入理解以下知识点才能玩转 Angular 模板： 对比各种 JS 模板引擎的设计思路 Mustache（八字胡）语法， {} 模板内的局部变量 属性绑定、事件绑定、双向绑定 在模板里面使用结构型指令 ngIf、ngFor、ngSwitch 在模板里面使用属性型指令 NgClass、NgStyle、NgModel 在模板里面使用管道格式化数据 对比各种 JS 模板引擎的设计思路什么是模板引擎？ 是指利用某种模板语言将页面制成模板，再依据业务逻辑将该模板语言翻译成业务数据，从而生成最终展示页面。 简单的讲就是根据静态HTMl元素和业务逻辑处理的数据结合渲染生成浏览器器需要的页面。 jQuery -&gt; Handlebars React -&gt; jsx 模板写法 Angular -&gt; 与“指令”紧密结合的模板语法 （vue 也是一样） 各种模板引擎的唯一目标就是提高开发效率、缩短时间成本。综合来说，无论是哪一种前端模板，大家都比较推崇“轻逻辑”（ logic-less ）的设计思路。 何为“轻逻辑”? 简而言之，所谓“轻逻辑”就是说，你不能在模板里面编写非常复杂的 JavaScript 表达式。比如，Angular 的模板语法就有规定： 你不能在模板里面 new 对象 不能使用=、+=、-=这类的表达式 不能用++、–运算符 不能使用位运算符 为什么要“轻逻辑”？ 本身的 Html 是不识别 if 、for 等操作的；模板引擎处于的地位就是帮忙编译转换纯HTMl元素。 在 HTML 加入复杂的逻辑，会加大模板引擎编译的时间和计算能力；而且也不建议复杂逻辑处理放到HTMl里来做，保证 HTML 的单一纯洁性；使用模板也是来做简单的插值相关的操作 JS 版的编译器需要在浏览器里面运行，搞得太复杂浏览器拖不动！ 最根本还是模板引擎不够强, 并不是万能的； 对于 Angular 来说，强调“轻逻辑”还有另一个原因：在组件的整个生命周期里面，模板函数会被执行很多次。你可以想象， Angular 每次要刷新组件的外观的时候，都需要去调用一下模板函数，如果你在模板里面编写了非常复杂的代码，一定会增加渲染时间，用户一定会感到界面有“卡顿”。 人眼的视觉延迟大约是100ms到400ms之间，如果整个页面的渲染时间超过400ms，界面基本上就卡得没法用了。有一些做游戏的开发者会追求60fps刷新率的细腻感觉，60分之1秒约等于16.7ms，如果 UI 整体的渲染时间超过了16.7ms，就没法达到这个要求了。 轻逻辑（ logic-less ）带来了效率的提升，也带来了一些不方便，比如很多模板引擎都实现了 if 语句，但是没有实现 else，所以开发者们在编写复杂业务逻辑的时候模板代码会显得非常啰嗦。 目前来说，并没有完美的方案能同时兼顾运行效率和语法表现能力，这里只能取一个平衡。 Mustache 语法关于 Mustache 语法，双花括号语法,你需要掌握3点: 它可以获取到组件里面定义的属性值。 它可以自动计算简单的数学表达式，例如: 加减乘除、取模 它可以获得方法的返回值。 插值语法关键代码实例： 123&lt;h3&gt; 欢迎来到&#123;&#123;title&#125;&#125;！&lt;/h3&gt; 1public title = 'Mustache 语法'; 简单的数学表达式求值： 1&lt;p&gt;1 + 5 = &#123;&#123; 1 + 5 &#125;&#125;&lt;/p&gt; 调用组件里面定义的方法： 1&lt;p&gt; &#123;&#123; getStr() &#125;&#125; &lt;/p&gt; 123public getStr(): string &#123; return '调用方法！'&#125; 属性绑定（[属性名]）属性绑定是用方括号来做的，写法： 12&lt;img [src]="imgSrc" /&gt;&lt;button [disabled]="isUnchanged"&gt;是否禁用&lt;/button&gt; 12public imgSrc:string = './images.png';public isUnchanged:boolean = true; 很明显，这种绑定是单向数据绑定，单一的读取值而已。 事件绑定 ( (事件名) )事件绑定是用圆括号来做的，写法： 1&lt;button (click)="btnClick($event)"&gt;点击事件&lt;/button&gt; 123pubic btnClick(e):void &#123; alert('点击事件测试～');&#125; 双向绑定 （ [(…)] ）你经常需要显示数据属性，并在用户作出更改时更新该属性。 在元素层面上，既要设置元素属性，又要监听元素事件变化。 双向绑定是通过方括号里面套一个圆括号 [(...)] 来做的，模板写法： 1&lt;app-sizer [(size)]="fontSizePx"&gt;&lt;/app-sizer&gt; 1public fontSizePx:number = 14; 模板内的局部变量在模板里面使用结构型指令Angular 有3个内置的结构型指令：*ngIf、*ngFor、ngSwitch。ngSwitch 的语法比较啰嗦，使用频率小一些, 了解就好。 *ngIf 代码实例： 12&lt;p *ngIf="isShow"&gt;显示还是不显示？&lt;/p&gt;&lt;button (click)="toggleShow()"&gt;控制显示隐藏&lt;/button&gt; 12345public isShow:boolean=true;public toggleShow():void &#123; this.isShow = !this.isShow;&#125; *ngFor 代码实例： 12345&lt;ul&gt; &lt;li *ngFor="let item of items; let i = index;"&gt; &#123;&#123;i+1&#125;&#125; - &#123;&#123; item.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345public items:Array&lt;any&gt;=[ &#123;name:"PyCoder"&#125;, &#123;name:"Jun ting"&#125;, &#123;name:"EcmaScript"&#125;]; *ngSwitch 代码实例： 12345&lt;div [ngSwitch]="mapStatus"&gt; &lt;p *ngSwitchCase="0"&gt;下载中...&lt;/p&gt; &lt;p *ngSwitchCase="1"&gt;正在读取...&lt;/p&gt; &lt;p *ngSwitchDefault&gt;系统繁忙...&lt;/p&gt;&lt;/div&gt; 1public mapStatus:number = 1; 特别注意：一个 HTML 标签上只能同时使用一个结构型的指令。 因为“结构型”指令会修改 DOM 结构，如果在一个标签上使用多个结构型指令，大家都一起去修改 DOM 结构，到时候到底谁说了算？ 那么需要在同一个 HTML 上使用多个结构型指令应该怎么办呢？有两个办法： 加一层空的 div 标签进行包裹 加一层 &lt;ng-container&gt; 在模板里面使用属性型指令使用频率比较高的3个内置指令是：NgClass、NgStyle、NgModel。 NgClass 使用案例代码： 12&lt;div [ngClass]="currentClasses"&gt;同时批量设置多个样式&lt;/div&gt;&lt;button (click)="setCurrentClasses()"&gt;设置&lt;/button&gt; 12345678910111213public currentClasses: [];public canSave: boolean = true;public isUnchanged: boolean = true;public isSpecial: boolean = true;public setCurrentClasses ():void &#123; this.currentClasses = &#123; 'saveable': this.canSave, 'modified': this.isUnchanged, 'special': this.isSpecial &#125;&#125;]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac - 打造自己的工作流]]></title>
    <url>%2F2018%2F05%2F19%2Fmac-make-self-workflow%2F</url>
    <content type="text"><![CDATA[Homebrew - Mac 必备软件管理神器基本市面上的软件都能通过 brew install softwareName 的方式进行安装。例如： git、google-chrmoe… 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; ITerm2 + oh-my-zsh - 终端命令行工具当然还是通过 brew进行安装 ITerm212# ITerm2$ brew install caskroom/cask/iterm2 都安装好后，我们就来配置下终端命令行工具，让它变的超酷起来。 1. iTerm2 -&gt; Make iTerm2 Default Term 2. 打开偏好设置preference，选中Keys，勾选Hotkey下的Show/hide iTerm2 with a system-wide hotkey，将热键设置为 ⌘+. ，这样你就可以通过 ⌘+. 全局热键来打开或关闭iTerm2窗口，非常方便 3. 配色方案，选用 solarized，下载解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors 4. 安装 oh-my-zsh 12# oh-my-zsh$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 5. 配置主题 1、 用 vim 编辑隐藏文件 .zshrc， 终端输入vi ~/.zshrcZSH_THEME=”agnoster” 将zsh主题修改为“agnoster” 2、 应用“agnoster”主题需要特殊的字体支持，否则会出现乱码情况， 使用 Meslo 字体，点开链接点击 view raw 下载字体 3、 安装字体到系统字体册 4、 在iTerm2中应用字体 iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font） 5、 重新打开iTerm2窗口（或新打开一个iTerm2窗口）即可以看到字体效果 推荐powerlevel9k 主题 1$ git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 然后编辑你的~/.zshrc，设置主题ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot; 6. 自动提示与命令补全 1、克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下 1$ git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 2、用 vim 编辑 .zshrc 文件，找到插件设置命令，默认是 plugins=(git) ，我们把它修改为plugins=(zsh-autosuggestions git) PS：当你重新打开终端时可能看不到变化，可能你的字体颜色太淡了，我们把其改亮一些： cd ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 用 vim 编辑 zsh-autosuggestions.zsh 文件，修改ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=10&#39; 7. 语法高亮效果 1$ brew install zsh-syntax-highlighting 在.zshrc文件的末尾添加下面这一段： 1source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 然后，加载.zshrc配置 1$ source ~/.zshrc 这里我使用的是 powerlevel9k 主题, 所以我的首行提示是这样修改的, 在 .zshrc文件末尾增加下面一行： 12# Powerlevel9k Theme configPOWERLEVEL9K_CONTEXT_TEMPLATE="%n" 或者，所有主题都适用的方式,还是在.zshrc文件里进行配置： 123456789 ZSH_THEME="powerlevel9k/powerlevel9k"# 隐藏用户名称(user@hostname) DEFAULT_USER=`id -un`# 含有icon的字型,前提你的字体有iconPOWERLEVEL9K_MODE='nerdfont-complete'# command line 左边提示内容(文件夹路径、文件夹读写状态、版本控制资讯)POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs) # &lt;= left prompt 设了 "dir"# command line 右边提示内容(状态、时间)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status time) 详细配置 最后显示成果： Visual Studio Code 终端配置字体： for Source Code Pro: “terminal.integrated.fontFamily”: “Source Code Pro for Powerline” for Meslo: “terminal.integrated.fontFamily”: “Meslo LG M for Powerline” the fontsize e.g.: “terminal.integrated.fontSize”: 14 推荐教材1*英文推荐教材2*中文 NVM - Node Version Manager 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 如果重启终端后发现，nvm 未找到此命令， 将下面的源代码行添加到您的配置文件（〜/ .bash_profile，〜/ .zshrc，〜/ .profile或〜/ .bashrc） 123export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion 安装Node 12345678# install$ nvm install 8# use$ nvm use default$ node -v$ npm -v NRM – NPM registry manager123456789# 全局安装$ npm install -g nrm# 查看当前 npm 源列表$ nom ls# 选择 taobao 源$ nom use taobao# 查看 npm 源是否更改$ npm config get]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3绘制腾讯QQ企鹅]]></title>
    <url>%2F2018%2F05%2F19%2Fcss3-qq-logo%2F</url>
    <content type="text"><![CDATA[绘制我们的企鹅 前提，你已经看过CSS3 绘制图形基本原理一文，已对一些基本图形绘制了解。 在线浏览 开始着手于 QQ 企鹅的绘制, 第一步基本框架的绘制。 通过对 Logo 图像的观察，按照层次划分来组合最终的效果。选择使用绝对位置 position:absolute;来布局各个元素。主要划分为头部，身体，围脖，双手，双脚。 1234567891011&lt;!-- QQ Logo box --&gt;&lt;div id="qq"&gt; &lt;!-- 头 --&gt; &lt;div class="head"&gt;&lt;/div&gt; &lt;!-- 身体 --&gt; &lt;div class="body"&gt;&lt;/div&gt; &lt;!-- 手 --&gt; &lt;div class="handWrapper"&gt;&lt;/div&gt; &lt;!-- 脚 --&gt; &lt;div class="footWrapper"&gt;&lt;/div&gt;&lt;/div&gt; 基本框架结构就是这样的，QQ 对于容器是通过绝对定位来对每个元素布局进行设置的。 QQ Logo 容器（画板）： 12345678910/** * QQ Logo 绘制 */#qq &#123; position: relative; margin: 0 auto; width: 420px; height: 400px; outline: gold solid 2px;&#125; 骨架出来了，那我们就开始一步步的进行绘制了，先从头开始： 绘制 head 前，还是跟步骤 1 一样，先对 head 的层次结构划分清楚，依次为：左眼、右眼、上嘴唇、下嘴唇、嘴唇的层次感体现 12345678910111213 &lt;!-- 头 --&gt;&lt;div class="head"&gt; &lt;!-- 左眼 --&gt; &lt;div class="left eye"&gt;&lt;/div&gt; &lt;!-- 右眼 --&gt; &lt;div class="right eye"&gt;&lt;/div&gt; &lt;!-- 上嘴唇 --&gt; &lt;div class="mouthTopContainer"&gt;&lt;/div&gt; &lt;!-- 下嘴唇 --&gt; &lt;div class="mouthBottomContainer"&gt;&lt;/div&gt; &lt;!-- 嘴唇上下层次感 --&gt; &lt;div class="lispContainer"&gt;&lt;/div&gt; &lt;/div&gt; 绘制 head 的轮廓： 1234567891011121314/* QQ head */.head &#123; position: absolute; top: 18px; left: 96px; width: 234px; height: 185px; border: 1px solid #000; /* 通过对border-radius 圆弧的层度来进行钩画 */ border-top-left-radius: 117px 117px; border-top-right-radius: 117px 117px; border-bottom-left-radius: 117px 68px; border-bottom-right-radius: 117px 68px;&#125; 图中为什么圆弧是设置成 border-bottom-left-radius: 117px 68px; 一般根据设计图出来后导出转成带有标尺图后，会自动计算出值；如果没有的话，那就要通过计算了。 然后依次绘制 head 其他结构： 眼睛 123456789101112131415161718/* 眼睛 */.eye &#123; position: absolute; width: 44px; height: 66px; border: 1px solid #000; border-radius: 50% 50%;&#125;.left.eye &#123; left: 62px; top: 50px;&#125;.right.eye &#123; left: 132px; top: 50px;&#125; 嘴 123456789101112131415161718/* QQ head -&gt; mouth */.mouthTopContainer &#123; position: absolute; top: 120px; left: 39px; width: 158px; height: 29px; border: 1px solid #000;&#125;.mouthBottomContainer &#123; position: absolute; top: 146px; left: 39px; width: 158px; height: 15px; border: 1px solid #000;&#125; 到这里基本头的骨架就出来，然后就是对头的骨架结构的线条进行修饰，现在太丑了，对吧！ 眼睛 12345678910111213&lt;!-- 左眼 --&gt;&lt;div class="left eye"&gt; &lt;!-- 眼球 --&gt; &lt;div class="innerLeftEye"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 右眼 --&gt; &lt;div class="right eye"&gt; &lt;!-- 眼球 --&gt; &lt;div class="innerRightEye"&gt; &lt;!-- 月牙眼球两端圆弧修饰 --&gt; &lt;div class="fix"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* QQ head -&gt; eye */.eye &#123; position: absolute; width: 44px; height: 66px; border: 1px solid #000; border-radius: 50% 50%;&#125;.left.eye &#123; left: 62px; top: 50px;&#125;.right.eye &#123; left: 132px; top: 50px;&#125;.innerLeftEye &#123; position: absolute; top: 20px; left: 20px; width: 18px; height: 24px; border-radius: 50%; border: 1px solid #000;&#125;.innerLeftEye::after &#123; content: ""; position: absolute; top: 6px; left: 9px; width: 6px; height: 8px; border: 1px solid #000; border-radius: 50%;&#125;.innerRightEye &#123; position: absolute; top: 20px; left: 8px; /* 月牙眼球外轮廓 */ width: 18px; height: 24px; border: 1px solid #000; border-top-left-radius: 50% 90%; border-top-right-radius: 50% 90%; border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%;&#125;.innerRightEye::after &#123; content: ""; position: absolute; bottom: -1px; left: 4px; /* 月牙眼球内部轮廓 */ width: 10px; height: 13px; border: 1px solid #000; border-top-left-radius: 50% 100%; border-top-right-radius: 35% 80%;&#125;.fix &#123; position: absolute; top: 17px; width: 4px; height: 4px; border: 1px solid #000; border-radius: 50%;&#125;.fix:after &#123; content: ""; position: absolute; top: 0; left: 14px; width: 4px; height: 4px; border: 1px solid #000; border-radius: 50%;&#125; 嘴 1234567891011121314151617&lt;!-- 上嘴唇 --&gt;&lt;div class="mouthTopContainer"&gt; &lt;div class="mouthTop"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 下嘴唇--&gt;&lt;div class="mouthBottomContainer"&gt; &lt;div class="mouthBottom"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 嘴唇上下层次感-咬合部位 --&gt;&lt;div class="lispContainer"&gt; &lt;div class="lips"&gt; &lt;div class="lipShadow left"&gt; &lt;/div&gt; &lt;div class="lipShadow right"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* QQ head -&gt; mouth */.mouthTopContainer &#123; /* 定位 */ position: absolute; top: 120px; left: 39px; width: 158px; height: 29px; overflow: hidden; /* 隐藏超出部分 */&#125;.mouthTop &#123; /* 上嘴唇轮廓 */ position: absolute; top: 0; left: 0; width: 158px; height: 34px; border: 1px solid #000; border-top-left-radius: 45% 34px; border-top-right-radius: 45% 34px;&#125;.mouthBottomContainer &#123; position: absolute; top: 146px; left: 39px; width: 158px; height: 15px; overflow: hidden; /* 隐藏超出部分 */&#125;.mouthBottom &#123; position: absolute; top: -4px; left: 0; width: 158px; height: 24px; border: 1px solid #000; border-top: none; border-bottom-left-radius: 45% 24px; border-bottom-right-radius: 45% 24px;&#125;/* 嘴唇上下层次感-咬合部位 */.lispContainer &#123; /* 定位 */ position: absolute; top: 146px; left: 60px; width: 116px; height: 24px;&#125;.lips &#123; position: absolute; top: 0; left: 0; width: 116px; height: 24px; border: 1px solid #ffa600; border-bottom-left-radius: 50% 100%; border-bottom-right-radius: 50% 100%;&#125; 基本 head 轮廓就是这样了，最后在把右眼眼球部分上个色，来进行层叠覆盖隐藏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.innerRightEye &#123; position: absolute; top: 20px; left: 8px; /* 月牙眼球外轮廓 */ width: 18px; height: 24px; /* border: 1px solid #000; */ border-top-left-radius: 50% 90%; border-top-right-radius: 50% 90%; border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%; background: black; box-shadow: 0 -1px 2px black;&#125;.innerRightEye::after &#123; content: ""; position: absolute; bottom: -1px; left: 4px; /* 月牙眼球内部轮廓 */ width: 10px; height: 13px; /* border: 1px solid #000; */ border-top-left-radius: 50% 100%; border-top-right-radius: 35% 80%; background: white;&#125;.fix &#123; position: absolute; top: 19px; width: 4px; height: 4px; /* border: 1px solid #000; */ border-radius: 50%; background: black;&#125;.fix:after &#123; content: ""; position: absolute; top: 0; left: 14px; width: 4px; height: 4px; /* border: 1px solid #000; */ border-radius: 50%; background: black;&#125; 接下来 开始绘制 QQ 的 body 部分，老样子对 body 进行层次结构划分：围巾、围巾尾、内轮廓、外轮廓 123456789101112131415&lt;!-- 身体 --&gt;&lt;div class="body"&gt; &lt;!-- 内轮廓 --&gt; &lt;div class="innerWrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 外轮廓 --&gt; &lt;div class="outerWrapper"&gt; &lt;div class="outer"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 围巾 --&gt; &lt;div class="scarf"&gt;&lt;/div&gt; &lt;!-- 围巾尾 --&gt; &lt;div class="scarfEnd"&gt;&lt;/div&gt;&lt;/div&gt; 先各个容器位置布局好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* QQ body */.body &#123; /* body 容器定位 */ position: absolute; top: 135px; left: 48px; width: 326px; height: 300px; /* border: 1px solid #000; */&#125;/* QQ body -&gt; scarf */.scarf &#123; position: absolute; top: -2px; left: 34px; width: 258px; height: 110px; border: 1px solid #000; border-top: none;&#125;/* QQ body -&gt; scarfEnd */.scarfEnd &#123; position: absolute; left: 74px; top: 90px; width: 52px; height: 64px; border: 3px solid black;&#125;/* QQ body -&gt; innerWrapper */.innerWrapper &#123; /* innerWrapper 容器定位 */ position: absolute; left: 30px; top: 76px; width: 280px; height: 200px; border: 1px solid #000;&#125;/* QQ body -&gt; outerWrapper */.outerWrapper &#123; /* outerWrapper 容器定位 */ position: absolute; top: 54px; overflow: hidden; width: 262px; left: 32px; height: 250px; border: 1px solid #000;&#125; 轮廓线条修正 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* QQ body */.body &#123; /* body 容器定位 */ position: absolute; top: 135px; left: 48px; width: 326px; height: 300px; /* border: 1px solid #000; */&#125;/* QQ body -&gt; scarf */.scarf &#123; position: absolute; top: -2px; left: 34px; width: 258px; height: 110px; border: 1px solid #000; border-top-left-radius: 30px 34px; border-top-right-radius: 38px 34px; border-bottom-left-radius: 50% 76px; border-bottom-right-radius: 50% 76px; border-top: none;&#125;/* QQ body -&gt; scarfEnd */.scarfEnd &#123; position: absolute; left: 74px; top: 90px; width: 52px; height: 64px; border: 3px solid black; border-bottom-left-radius: 50% 43%; border-bottom-right-radius: 15px; border-top-left-radius: 20% 57%;&#125;/* QQ body -&gt; innerWrapper */.innerWrapper &#123; /* innerWrapper 容器定位 */ position: absolute; left: 30px; top: 76px; width: 280px; height: 200px; overflow: hidden;&#125;.inner &#123; position: absolute; left: 25px; top: -71px; width: 218px; height: 210px; border: 1px solid #000; border-radius: 50%;&#125;/* QQ body -&gt; outerWrapper */.outerWrapper &#123; /* outerWrapper 容器定位 */ position: absolute; top: 54px; overflow: hidden; width: 262px; left: 32px; height: 250px;&#125;.outer &#123; position: absolute; top: -84px; width: 260px; height: 250px; border: 1px solid #000; border-radius: 125px;&#125; 大致轮廓基本已经出来了，还有一些内部线条，等后面在来慢慢绘制。 接下来我们来绘制 hand 部分，安装老路子层次结构划分：左手、右手； 手的样子需要通过两个 div 进行整合才能绘制出来，所以再次划分： 左手上、左手下、右手上、右手下 123456789101112131415&lt;!-- 手 --&gt;&lt;div class="handWrapper"&gt; &lt;div class="leftHandTopContainer"&gt; &lt;div class="leftHandTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="leftHandBottomContainer"&gt; &lt;div class="leftHandBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightHandTopContainer"&gt; &lt;div class="rightHandTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightHandBottomContainer"&gt; &lt;div class="rightHandBottom"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* QQ handWrapper */.handWrapper &#123; /* 定位手的起始点 */ position: absolute; top: 219px; left: 7px;&#125;/* QQ handWrapper -left */.leftHandTopContainer &#123; /* 定位 */ position: absolute; top: 55px; left: 50px; width: 118px; height: 26px; border: 1px solid #000; transform-origin: bottom left; transform: rotate(-70deg);&#125;.leftHandBottomContainer &#123; /* 定位 */ position: absolute; top: 78px; left: 50px; width: 100px; height: 30px; border: 1px solid #000; transform-origin: top left; transform: rotate(-70deg);&#125;/* QQ handWrapper -right */.rightHandTopContainer &#123; /* 定位 */ position: absolute; top: 47px; left: 240px; width: 118px; height: 34px; border: 1px solid #000; transform-origin: bottom right; transform: rotate(65deg);&#125;.rightHandBottomContainer &#123; /* 定位 */ position: absolute; top: 81px; left: 248px; width: 110px; height: 58px; border: 1px solid #000; transform-origin: top right; transform: rotate(90deg);&#125; 线条轮廓修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* QQ handWrapper */.handWrapper &#123; /* 定位手的起始点 */ position: absolute; top: 219px; left: 7px;&#125;/* QQ handWrapper -left */.leftHandTopContainer &#123; /* 定位 */ position: absolute; top: 55px; left: 50px; width: 118px; height: 26px; /* border: 1px solid #000; */ transform-origin: bottom left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandTop &#123; /* 上半部分 */ width: 128px; height: 54px; border: 1px solid #050346; border-top-left-radius: 44% 38px; border-top-right-radius: 56% 33px;&#125;.leftHandBottomContainer &#123; /* 定位 */ position: absolute; top: 78px; left: 50px; width: 100px; height: 30px; /* border: 1px solid #000; */ transform-origin: top left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandBottom &#123; position: absolute; top: -26px; width: 128px; height: 44px; border: 1px solid #050346; border-bottom-left-radius: 48% 20px; border-bottom-right-radius: 52% 23px;&#125;/* QQ handWrapper -right */.rightHandTopContainer &#123; /* 定位 */ position: absolute; top: 47px; left: 240px; width: 118px; height: 34px; /* border: 1px solid #000; */ transform-origin: bottom right; transform: rotate(65deg); overflow: hidden;&#125;.rightHandTop &#123; position: absolute; left: -30px; width: 148px; height: 54px; border: 1px solid #050346; border-top-right-radius: 41% 54px; border-top-left-radius: 59% 48px;&#125;.rightHandBottomContainer &#123; /* 定位 */ position: absolute; top: 81px; left: 248px; width: 110px; height: 58px; /* border: 1px solid #000; */ transform-origin: top right; transform: rotate(90deg); overflow: hidden;&#125;.rightHandBottom &#123; position: absolute; top: 1px; left: 38px; width: 68px; height: 28px; border: 1px solid #000; border-bottom-right-radius: 100% 40px;&#125; 是不是漂亮很多了， 那快点把脚的部分也完成吧,和手的结构基本类似。 123456789101112131415&lt;!-- 脚 --&gt;&lt;div class="footWrapper"&gt; &lt;div class="leftFootTopWrapper"&gt; &lt;div class="leftFootTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="leftFootBottomWrapper"&gt; &lt;div class="leftFootBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightFootTopWrapper"&gt; &lt;div class="rightFootTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightFootBottomWrapper"&gt; &lt;div class="rightFootBottom"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 基础位置布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* QQ footerWrapper */.footWrapper &#123; /* 定位起始点 */ position: absolute; top: 292px; left: 80px; width: 300px; height: 80px; border: 1px solid #000;&#125;/* QQ footerWrapper -&gt; left */.leftFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 16px; left: -1px; width: 130px; height: 37px; border: 1px solid #000;&#125;.leftFootBottomWrapper &#123; position: absolute; top: 52px; left: -1px; width: 130px; height: 38px; border: 1px solid #000;&#125;/* QQ footerWrapper -&gt; right */.rightFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 22px; left: 134px; width: 130px; height: 38px; border: 1px solid #000;&#125;.rightFootBottomWrapper &#123; position: absolute; top: 52px; left: 134px; width: 134px; height: 38px; border: 1px solid #000;&#125; 轮廓调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* QQ footerWrapper */.footWrapper &#123; /* 定位起始点 */ position: absolute; top: 292px; left: 80px; width: 300px; height: 80px; /* border: 1px solid #000; */&#125;/* QQ footerWrapper -&gt; left */.leftFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 16px; left: -1px; width: 130px; height: 37px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootTop &#123; position: absolute; top: -10px; left: 3px; width: 120px; height: 60px; border: 4px solid black; border-top-left-radius: 80% 70%;&#125;.leftFootBottomWrapper &#123; position: absolute; top: 52px; left: -1px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 44%; border-top-right-radius: 50% 44%; border-bottom-left-radius: 50% 56%; border-bottom-right-radius: 50% 56%;&#125;/* QQ footerWrapper -&gt; right */.rightFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 22px; left: 134px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootTop &#123; position: absolute; top: 0px; left: 4px; width: 120px; height: 60px; border: 4px solid black; border-top-right-radius: 32% 65%;&#125;.rightFootBottomWrapper &#123; position: absolute; top: 52px; left: 134px; width: 134px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 56%; border-top-right-radius: 50% 56%; border-bottom-left-radius: 50% 44%; border-bottom-right-radius: 50% 44%;&#125; 基本整体框架结构就出来了，开始上色吧。上色的过程可以帮助我们调整 z-index，也就是各个模块的重叠层次，遮盖了一些无用的线条和框角。 head 开始 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/* QQ head */.head &#123; position: absolute; top: 18px; left: 96px; width: 234px; height: 185px; border: 1px solid #000; border-top-left-radius: 117px 117px; border-top-right-radius: 117px 117px; border-bottom-left-radius: 117px 68px; border-bottom-right-radius: 117px 68px; background: #000;&#125;/* QQ head -&gt; eye */.eye &#123; position: absolute; width: 44px; height: 66px; border: 1px solid #000; border-radius: 50% 50%; background: #fff;&#125;.left.eye &#123; left: 62px; top: 50px;&#125;.right.eye &#123; left: 132px; top: 50px;&#125;.innerLeftEye &#123; position: absolute; top: 20px; left: 20px; width: 18px; height: 24px; border-radius: 50%; border: 1px solid #000; background: #000;&#125;.innerLeftEye::after &#123; content: ""; position: absolute; top: 6px; left: 9px; width: 6px; z-index: 11; height: 8px; /* border: 1px solid #000; */ border-radius: 50%; background: #fff;&#125;.innerRightEye &#123; position: absolute; top: 20px; left: 8px; /* 月牙眼球外轮廓 */ width: 18px; height: 24px; /* border: 1px solid #000; */ border-top-left-radius: 50% 90%; border-top-right-radius: 50% 90%; border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%; background: black; box-shadow: 0 -1px 2px black;&#125;.innerRightEye::after &#123; content: ""; position: absolute; bottom: -1px; left: 4px; /* 月牙眼球内部轮廓 */ width: 10px; height: 13px; /* border: 1px solid #000; */ border-top-left-radius: 50% 100%; border-top-right-radius: 35% 80%; background: #fff;&#125;.fix &#123; position: absolute; top: 19px; width: 4px; height: 4px; /* border: 1px solid #000; */ border-radius: 50%; background: #000;&#125;.fix:after &#123; content: ""; position: absolute; top: 0; left: 14px; width: 4px; height: 4px; /* border: 1px solid #000; */ border-radius: 50%; background: black;&#125;/* QQ head -&gt; mouth */.mouthTopContainer &#123; /* 定位 */ position: absolute; top: 120px; left: 39px; z-index: 1; width: 158px; height: 29px; overflow: hidden; /* 隐藏超出部分 */&#125;.mouthTop &#123; /* 上嘴唇轮廓 */ position: absolute; top: 0; left: 0; z-index: 1; width: 158px; height: 34px; border: 1px solid #ffa600; border-top-left-radius: 45% 34px; border-top-right-radius: 45% 34px; background: #ffa600;&#125;.mouthBottomContainer &#123; position: absolute; top: 146px; left: 39px; z-index: 1; width: 158px; height: 15px; overflow: hidden; /* 隐藏超出部分 */&#125;.mouthBottom &#123; position: absolute; top: -4px; left: 0; z-index: 1; width: 158px; height: 24px; border: 1px solid #ffa600; border-top: none; border-bottom-left-radius: 45% 24px; border-bottom-right-radius: 45% 24px; background: #ffa600;&#125;/* 嘴唇上下层次感-咬合部位 */.lispContainer &#123; /* 定位 */ position: absolute; top: 146px; left: 60px; width: 116px; height: 24px;&#125;.lips &#123; position: absolute; top: 0; left: 0; width: 116px; height: 24px; border: 1px solid #ffa600; border-bottom-left-radius: 50% 100%; border-bottom-right-radius: 50% 100%; background: #ffa600;&#125; body 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* QQ body */.body &#123; /* body 容器定位 */ position: absolute; top: 135px; left: 48px; width: 326px; height: 300px; /* border: 1px solid #000; */&#125;/* QQ body -&gt; scarf */.scarf &#123; position: absolute; top: -2px; left: 34px; z-index: 5; width: 258px; height: 110px; border: 1px solid #000; border-top-left-radius: 30px 34px; border-top-right-radius: 38px 34px; border-bottom-left-radius: 50% 76px; border-bottom-right-radius: 50% 76px; border-top: none; background: #fb0009;&#125;/* QQ body -&gt; scarfEnd */.scarfEnd &#123; position: absolute; left: 74px; top: 90px; width: 52px; height: 64px; border: 3px solid black; border-bottom-left-radius: 50% 43%; border-bottom-right-radius: 15px; border-top-left-radius: 20% 57%; background: #fb0009;&#125;/* QQ body -&gt; innerWrapper */.innerWrapper &#123; /* innerWrapper 容器定位 */ position: absolute; left: 30px; top: 76px; width: 280px; height: 200px; overflow: hidden;&#125;.inner &#123; position: absolute; left: 25px; top: -71px; width: 218px; height: 210px; border: 1px solid #000; border-radius: 50%; background: #fff;&#125;/* QQ body -&gt; outerWrapper */.outerWrapper &#123; /* outerWrapper 容器定位 */ position: absolute; top: 54px; overflow: hidden; width: 262px; left: 32px; height: 250px;&#125;.outer &#123; position: absolute; top: -84px; width: 260px; height: 250px; border: 1px solid #000; border-radius: 125px; background: #000;&#125; 上色后你会发现，有的图层显示先后顺序不对，需要调整下先后顺序。 head &gt; body body 里（scafEnd &gt; inner &gt; outer） hand 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* QQ handWrapper -left */.leftHandTopContainer &#123; /* 定位 */ position: absolute; top: 55px; left: 50px; width: 118px; height: 26px; /* border: 1px solid #000; */ transform-origin: bottom left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandTop &#123; /* 上半部分 */ width: 128px; height: 54px; border: 1px solid #050346; border-top-left-radius: 44% 38px; border-top-right-radius: 56% 33px; background: #000;&#125;.leftHandBottomContainer &#123; /* 定位 */ position: absolute; top: 78px; left: 50px; width: 100px; height: 30px; /* border: 1px solid #000; */ transform-origin: top left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandBottom &#123; position: absolute; top: -26px; width: 128px; height: 44px; border: 1px solid #050346; border-bottom-left-radius: 48% 20px; border-bottom-right-radius: 52% 23px; background: #000;&#125;/* QQ handWrapper -right */.rightHandTopContainer &#123; /* 定位 */ position: absolute; top: 47px; left: 240px; width: 118px; height: 34px; /* border: 1px solid #000; */ transform-origin: bottom right; transform: rotate(65deg); overflow: hidden;&#125;.rightHandTop &#123; position: absolute; left: -30px; width: 148px; height: 54px; border: 1px solid #050346; border-top-right-radius: 41% 54px; border-top-left-radius: 59% 48px; background: #000;&#125;.rightHandBottomContainer &#123; /* 定位 */ position: absolute; top: 81px; left: 248px; width: 110px; height: 58px; /* border: 1px solid #000; */ transform-origin: top right; transform: rotate(90deg); overflow: hidden;&#125;.rightHandBottom &#123; position: absolute; top: 1px; left: 38px; width: 68px; height: 28px; border: 1px solid #000; border-bottom-right-radius: 100% 40px; background: #000;&#125; footer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* QQ footerWrapper */.footWrapper &#123; /* 定位起始点 */ position: absolute; top: 292px; left: 80px; width: 300px; height: 80px; /* border: 1px solid #000; */&#125;/* QQ footerWrapper -&gt; left */.leftFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 16px; left: -1px; width: 130px; height: 37px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootTop &#123; position: absolute; top: -10px; left: 3px; width: 120px; height: 60px; border: 4px solid black; border-top-left-radius: 80% 70%; background: #ff9c00;&#125;.leftFootBottomWrapper &#123; position: absolute; top: 52px; left: -1px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 44%; border-top-right-radius: 50% 44%; border-bottom-left-radius: 50% 56%; border-bottom-right-radius: 50% 56%; background: #ff9c00;&#125;/* QQ footerWrapper -&gt; right */.rightFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 22px; left: 134px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootTop &#123; position: absolute; top: 0px; left: 4px; width: 120px; height: 60px; border: 4px solid black; border-top-right-radius: 32% 65%; background: #ff9c00;&#125;.rightFootBottomWrapper &#123; position: absolute; top: 52px; left: 134px; width: 134px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 56%; border-top-right-radius: 50% 56%; border-bottom-left-radius: 50% 44%; border-bottom-right-radius: 50% 44%; background: #ff9c00;&#125; 到了这里基本完成了 90% 了， 剩下的就是线条优化，使 QQ 看起来更有层次感、立体感。 嘴唇 嘴巴的形状不够性感、立体；绘制一个斜边三角形，修复嘴唇的层次感。 绘制这样一个斜边三角形，步骤分解如图所示： 先是绘制一个普通三角形，通过逆时针旋转得到一个修复三角形，那么相对称的修复三角形可以通过使用 rotateY，绕着 Y 轴旋转 180 度，来得到。 12345678&lt;!-- 嘴唇上下层次感 --&gt;&lt;div class="lispContainer"&gt; &lt;div class="lips"&gt; &lt;!-- 左右上下嘴唇咬合阴影 --&gt; &lt;div class="lipShadow left"&gt;&lt;/div&gt; &lt;div class="lipShadow right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 嘴唇上下层次感-咬合部位 */.lispContainer &#123; /* 定位 */ position: absolute; top: 146px; left: 60px; width: 116px; height: 24px;&#125;.lips &#123; position: absolute; top: 0; left: 0; width: 116px; height: 24px; border: 1px solid #ffa600; border-bottom-left-radius: 50% 100%; border-bottom-right-radius: 50% 100%; background: #ffa600;&#125;.lipShadow &#123; position: absolute; width: 0px; height: 0px; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-right: 8px solid black; transform-origin: top right; transform: rotate(-60deg); z-index: 2;&#125;.lipShadow.left &#123; top: 4px; left: -12px; transform: rotate(-60deg);&#125;.lipShadow.right &#123; top: 4px; left: 111px; transform: rotate(60deg) rotateY(180deg);&#125; 围巾 围脖竟然没折痕，不立体； 通过绘制一个“小尾巴”来进行美化 1234border-right: 6px solid black;width: 100px;height: 70px;border-bottom-right-radius: 70px 70px; 当对一个角应用圆角样式，如果这个角相邻的两个 border 一个有定义而一个无定义，那么绘制的结果就是由粗到细的“小尾巴了”。[在整个绘制过程中，同一个图形它的绘制方法有很多种，例如一个矩形可以用 width x height 构成，也可以由 border x height(width)构成，甚至可以由 border 组合(width = height = 0)构成，根据情况选择吧。] 12345678910&lt;!-- 围巾 --&gt;&lt;div class="scarf"&gt; &lt;div class="scarfShadow"&gt;&lt;/div&gt; &lt;div class="scarfShadowRight"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 围巾尾 --&gt;&lt;div class="scarfEnd"&gt; &lt;div class="scarfEndShadow"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* QQ body -&gt; scarf */.scarf &#123; position: absolute; top: -2px; left: 34px; z-index: 5; width: 258px; height: 110px; border: 4px solid #000; border-top-left-radius: 30px 34px; border-top-right-radius: 38px 34px; border-bottom-left-radius: 50% 76px; border-bottom-right-radius: 50% 76px; border-top: none; background: #fb0009;&#125;.scarfShadowLeft &#123; position: absolute; top: 0px; left: 6px; width: 60px; height: 70px; /* border: 4px solid #000; */ border-top: 6px solid #000; border-top-left-radius: 90px 120px; border-top-right-radius: 30px 30px; transform: rotate(-79deg);&#125;.scarfShadowRight &#123; position: absolute; top: 8px; left: 143px; width: 100px; height: 70px; /* border: 4px solid #000; */ border-right: 6px solid black; width: 100px; border-bottom-right-radius: 70px 70px; border-right: 6px solid black;&#125;/* QQ body -&gt; scarfEnd */.scarfEnd &#123; position: absolute; left: 74px; top: 90px; width: 52px; height: 64px; border: 3px solid black; border-bottom-left-radius: 50% 43%; border-bottom-right-radius: 15px; border-top-left-radius: 20% 57%; background: #fb0009; z-index: 4;&#125;.scarfEndShadow &#123; position: absolute; top: 6px; left: 12px; width: 20px; height: 20px; /* border: 4px solid #000; */ border-top: 6px solid #000; border-top-left-radius: 30px 30px; transform-origin: top right; transform: skewX(4deg) scaleY(1.5) rotate(-60deg);&#125; 脚 也是通过绘制小尾巴来进行美化 12345678910111213141516171819&lt;!-- 脚 --&gt;&lt;div class="footWrapper"&gt; &lt;div class="leftFootTopWrapper"&gt; &lt;div class="leftFootTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="leftFootBottomWrapper"&gt; &lt;div class="leftFootBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 脚趾间隔线条 --&gt; &lt;div class="toe left"&gt;&lt;/div&gt; &lt;div class="rightFootTopWrapper"&gt; &lt;div class="rightFootTop"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="rightFootBottomWrapper"&gt; &lt;div class="rightFootBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 脚趾间隔线条 --&gt; &lt;div class="toe right"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* QQ footerWrapper */.footWrapper &#123; /* 定位起始点 */ position: absolute; top: 292px; left: 80px; width: 300px; height: 80px; /* border: 1px solid #000; */&#125;.toe &#123; position: absolute; width: 25px; height: 20px; /* border: 4px solid #000; */ border-top: 4px solid black; border-top: 4px solid black; border-top-right-radius: 30px 30px; border-top-left-radius: 10px 10px; transform-origin: top left; z-index: 10;&#125;/* QQ footerWrapper -&gt; left */.leftFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 16px; left: -1px; width: 130px; height: 37px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootTop &#123; position: absolute; top: -10px; left: 3px; width: 120px; height: 60px; border: 4px solid black; border-top-left-radius: 80% 70%; background: #ff9c00;&#125;.toe.left &#123; top: 50px; left: 2px; transform: rotate(-45deg);&#125;.leftFootBottomWrapper &#123; position: absolute; top: 52px; left: -1px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.leftFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 44%; border-top-right-radius: 50% 44%; border-bottom-left-radius: 50% 56%; border-bottom-right-radius: 50% 56%; background: #ff9c00;&#125;/* QQ footerWrapper -&gt; right */.rightFootTopWrapper &#123; /* 定位左脚上容器 */ position: absolute; top: 22px; left: 134px; width: 130px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootTop &#123; position: absolute; top: 0px; left: 4px; width: 120px; height: 60px; border: 4px solid black; border-top-right-radius: 32% 65%; background: #ff9c00;&#125;.toe.right &#123; top: 50px; left: 264px; transform: rotate(45deg) rotateY(180deg);&#125;.rightFootBottomWrapper &#123; position: absolute; top: 52px; left: 134px; width: 134px; height: 38px; /* border: 1px solid #000; */ overflow: hidden;&#125;.rightFootBottom &#123; position: absolute; top: -30px; left: 3px; width: 120px; height: 60px; border: 4px solid #000; border-top-left-radius: 50% 56%; border-top-right-radius: 50% 56%; border-bottom-left-radius: 50% 44%; border-bottom-right-radius: 50% 44%; background: #ff9c00;&#125; 大功告成，一个生动的 QQ 企鹅就绘制完了～ 介绍下这个过程中几个比较典型的图形绘制方法： 1、企鹅的眼睛：椭圆，直接设置 border-radius:50% 50%; 即可[因为宽高分别为 44px 和 66px，所以也可以这样设定：border-radius: 22px / 33px] 2、围脖的尾部：一个圆角各异的矩形，所以这里需要对几个角分别设定 border-radius，微调的结果为 123border-bottom-left-radius: 50% 43%;border-bottom-right-radius: 15px;border-top-left-radius: 20% 57%; 3、企鹅的胳膊：手的绘制较为麻烦一点，可以分为上下两个部分，将绘制的结果拼接到一起。那么对于不需要的部分怎么办呢？我们可以将上(下)部分放到一个 div(container)中，利用 overflow:hidden 的属性来截取所要的部分。绘制复杂图形的时候常用的方法就是切割和拼接，将图形切割成一个个简单的小块，通过层叠和旋转变化进行组合。 使用 transform:rotate(deg)的时候，优先设定 transform-origin 属性，会比较方便。设定的点作为中心点，整个图形绕着这个点进行角度变化。例如：transform-origin:bottom left， 使用左下角作为原点。也可以使用具体的像素值和百分比。 在基本的框架线条中比非常多的使用了 border-radius 用于构造各种曲线条，小企鹅是圆圆胖胖的，:) 本文参考 源码]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo + Github 搭建个人静态博客]]></title>
    <url>%2F2018%2F05%2F19%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[使用 Hexo 搭建静态博客什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 12345678910111213141516171819npm install -g hexo-cli# 安装是否成功 ~/Life  hexo version  14:35:29hexo-cli: 1.1.0os: Darwin 17.5.0 darwin x64http_parser: 2.8.0node: 8.11.1v8: 6.2.414.50uv: 1.19.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2oicu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 工具都备好，开始搭建博客请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件,⚠️ 要空文件夹哦～ 1234# 初始化hexo项目仓库$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 初始化完成后，指定文件夹的目录如下： 1234567891011.├── _config.yml // 网站配置信息├── package.json // 应用程序的信息├── scaffolds // 模版 文件夹│ ├── draft.md│ ├── page.md│ └── post.md├── source // 资源文件夹│ └── _posts└── themes // 主题 └── landscape 到这里一个最基础的博客就搭建出来了，让我们运行起来: 1hexo server 与GitHub关联上GitHub Page 实现方式，目前我知道的是三种： 创建一个跟你github账号相关的仓库，github默认给你的域名就是 [username].github.io 创建仓库，在 setting 中通过设置 Github page 的方式 创建 gh-pages 分支的方式 这三种方式其实属于两种基本的 GitHub Pages 类型：用户/组织 Pages 和 项目 Pages。 用户/组织 Pages 存在于一个特定的 GitHub Pages 文件专有库中。你将使用用户名来命名这个库，比如 twitchbody.github.io；master分支 上的内容将用于构建和发布你的 GitHub Pages 网页。 不像用户和组织的 Pages，项目 Pages 是作为一个项目保存在同一个库中, 以作为项目介绍和文档存在。gh-pages分支用来构建和发布项目 Pages 网站。如果没有 自定义的域名，项目 Pages 网站将服务在用户 Pages 网站的子域名下：username.github.io/projectName。 这里我使用方式3: 建立一个项目 Pages，你需要在你的库中新建一个新的 orphan 分支（一个与现存分支没有共同的历史的分支）。 1234567# 进入项目$ cd pycoder-hexo# 创建分支$ git checkout --orphan gh-pages# 清除分支所有内容，保证是一个干净的分支$ git rm -rf . 然后，创建 index.html 文件做测试: 123456# 创建$ echo &quot;My Page!&quot; &gt; index.html$ git add .$ git commit -m &quot;my first page&quot;$ git push origin gh-pages 接着，进入setting，设置下 Github page: 使用自定义域名，需要你到域名服务商里进行增加一个域名解析： ⚠️, 这里要是没有自定义域名，到时候部署 hexo 生成的静态文件的时候，站点访问静态资源会出现 404错误，你会发现路径出现问题。 打造超酷的博客安装主题我选择的是比较火和流行的 Next主题： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题需要在 _config.yml文件进行配置： 1234# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 设定主题Next是一个主题，三种外观，选您所好！挑选你看的顺眼的外观。 12 配置站点相关信息的配置, 可以在 _config.yml 中修改大部份的配置。了解相关配置，可以参考 配置文档，进行你的基础信息设置。 指令之前我们初始化项目的时候已经使用过2个 hexo 指令了 hexo init pyCoder 和 hexo version, 接下来我们详细了解其他的hexo指令，想要hexo玩出花，指令是必须的～ new新建一篇文章 1hexo new [layout] &lt;title&gt; 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate生成静态文件。 123456789hexo generate# 简写hexo g# 文件生成后立即部署网站hexo generate -d // (-d,--deploy)# 监视文件变动hexo generate -w // (-w, --watch) publish发表草稿。 1hexo publish [layout] &lt;filename&gt; server启动服务器。默认情况下，访问网址为： http://localhost:4000/。 12345678910hexo serve# 重设端口hexo serve -p 8080 // (-p, --port)# 只使用静态文件hexo serve -s // (-s, --static)# 启动日记记录，使用覆盖记录格式hexo serve -l // (-l, --log) deploy部署网站。 123456hexo deploy# 简写hexo d# 部署之前预先生成静态文件 hexo deploy -g // (-g, --generate) render渲染文件。 1234hexo render &lt;file1&gt; [file2] ...# 设置输出路径 hexo render &lt;file1&gt; [file2] -o path // (-o, --output) migrate从其他博客系统 迁移内容 1hexo migrate &lt;type&gt; clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。 1hexo clean 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1hexo list &lt;type&gt; 列出网站资料。 version显示 Hexo 版本。 1hexo version 安全模式1hexo safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 Hexo GitHub 的 issue 上 。 简洁模式1hexo --silent 隐藏终端信息。 自定义配置文件的路径1hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿1hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
